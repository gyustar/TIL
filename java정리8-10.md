## 인터페이스

> 인터페이스의 역할

자바에서 인터페이스는 객체의 사용 방법을 정의한 타입이다. 인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다. 인터페이스는 개발 코드와 객체간의 접점이다. 개발 코드는 객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 된다. 따라서 개발 코드를 수정하지 않고, 시용하는 객체를 변경할 수 있다. 인터페이스는 여러 객체들과 사용이 가능하기 때문에 코드 변경 없이 실행 내용과 리턴값을 다양화할 수 있다.

> 인터페이스 선언

인터페이스는 ~.java 형태의 소스 파일로 작성되고 컴파일러(javac.exe)를 통해 ~.class 형태로 컴파일되기 때문에 물리적 형태는 클래스와 동일하다. 차이점은 소스를 작성할 때 선언하는 방법이 다르다. 인터페이스 선언은 class 키워드 대신에 interface 키워드를 사용한다. 멤버로는 상수 필드와 메소드(추상, 디폴트, 정적)만을 가진다. 
- 인터페이스는 데이터를 저장할 수 없기 때문에 상수 필드만 선언할 수 있다. 인터페이스 상수는 static{}블록으로 초기화될 수 없기 때문에 선언과 동시에 초기값을 지정해야 한다.
- 인터페이스를 통해 호출된 메소드는 최종적으로 객체에서 실행된다. 따라서 호출 방법만 기술하고 실행 블록이 없는 추상 메소드를 선언한다. 인터페이스에서는 public abstract를 생략하더라도 컴파일 과정에서 붙게 된다.
- 디폴트 메소드는 default 키워드가 리턴 타입 앞에 붙는다. public 특성을 갖기 때문에 public은 생략 가능하다. 자바8부터 사용 가능.
- 정적 메소드의 형태는 클래스의 정적 메소드와 동일하다. 마찬가지로 publc 특성을 갖고, 생략 가능하다. 자바8부터 사용 가능.

> 인터페이스 구현(implement)

개발 코드가 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다. 객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야 한다. 이러한 객체를 인터페이스의 구현 객체라고 하고, 구현 객체를 생성하는 클래스를 구현 클래스라고 한다.
- 구현 클래스는 인터페이스 타입으로 사용할 수 있음을 알려주기 위해 클래스 선언부에 implements 키워드를 추가하고 인터페이스명을 명시해야 한다.
  ```java
  public class 구현클래스명 implements 인터페이스명 {
      //인터페이스에 선언된 추상 메소드의 실체 메소드 선언
  }
  ```
  - 인터페이스의 모든 메소드는 기본적으로 public 접근 제한을 갖기 때문에 구현 클래스의 실체 메소드들도 public보다 더 낮은 접근 제한으로 작성될 수 없다.
  - 만약 인터페이스의 추상메소드에 대응하는 실체 메소드가 구현 클래스에서 작성되지 않으면 클래스는 자동적으로 추상 클래스가 된다. 이 경우 abstract 키워드를 추가해야 한다.
  - 실체 메소드에 @Override 어노테이션을 붙여주면 추상메소드에 대한 정확한 실체 메소드인지 컴파일러가 체크해준다. 
  - 인터페이스로 구현 객체를 사용하려면 인터페이스 변수를 선언하고, new 연산자로 구현 객체를 대입해야 한다. 인터페이스 변수는 참조 타입이기 때문에 구현 객체가 대입되면 구현 객체의 번지를 저장한다.<br>
  *ex) 인터페이스이름 변수 = new 클래스명;
- 일회성의 구현 객체를 만들 경우, 이를 위해 소스 파일을 만들고 클래스를 선언하는 것은 비효율적이다. 자바는 소스 파일을 만들지 않고도 구현 객체를 만들 수 있는 **익명 구현 객체**를 제공한다.
  ```java
  //익명 구현 객체를 생성해서 인터페이스 변수에 대입
  인터페이스 변수 = new 인터페이스() {
      //인터페이스에 선언된 추상 메소드의 실체 메소드 선언
  };
  /*필드와 메소드를 선언할 수 있지만, 익명 객체 안에서만 사용할 수 있고
  인터페이스 변수로 접근할 수 없다.*/
  ```
  익명 구현 객체는 컴파일러에 의해 자동으로 클래스 파일이 만들어진다.
- 객체는 다수의 인터페이스 타입으로 사용할 수 있다. 이 경우 구현 클래스는 다음과 같이 작성된다.
  ```java
  public class 구현클래스명 implements 인터페이스A, 인터페이스B {
      //인터페이스A에 선언된 추상 메소드의 실체 메소드 선언
      //인터페이스B에 선언된 추상 메소드의 실체 메소드 선언
  }
  ```

> 인터페이스 사용

개발 코드에서 인터페이스는 클래스의 필드, 생성자/메소드의 매개 변수, 생성자/매소드의 로컬 변수로 선언될 수 있다.
- 구현 객체가 인터페이스 타입에 대입되면 인터페이스의 추상 메소드를 호출할 수 있게 된다.
  ```java
  RemoteControl rc = new Television;
  rc.tutn)n(); //Television의 turn)n()실행
  ```
- 디폴트 메소드는 인터페이스에 선언되지만, 인터페이스에서 바로 사용할 수 없다. 추상 메소드가 아닌 인스턴스 메소드이므로 구현 객체가 있어야 한다. 디폴트 메소드는 인터페이스의 모든 구현 객체가 가지고 있는 기본 메소드이다. 구현 클래스 작성 시 디폴트 메소드를 오버라이딩 하면 호출될 때 재정의한 메소드가 호출된다.
- 정적 메소드는 인터페이스로 바로 호출이 가능하다. *ex) 인터페이스명.메소드*

> 타입 변환과 다형성

- 인터페이스도 다형성을 구현하는 기술이 사용된다. 인터페이스 타입에 어떤 구현 객체를 대입하느냐에 따라 실행 결과가 달라진다. 
- 구현 객체가 인터페이스 변수에 대입될 경우 자동 타입 변환이 일어난다. 인터페이스 구현 클래스를 상속하는 자식 클래스 역시 인터페이스 타입으로 자동 타입 변환된다.
- 같은 인터페이스 타입의 인터페이스 변수는 배열로 만들어서 관리할 수 있다.
- 필드의 값을 대입할 때 외에도, 메소드 호출 시 매개값으로 들어가는 경우에도 자동 타입 변환이 일어난다.
- 구현 객체가 인터페이스 타입으로 자동 변환하면, 인터페이스에 선언된 메소드만 사용 가능하다. 이 때 강제 타입 변환을 해서 다시 구현 클래스 타입으로 변환하면 구현 클래스의 필드와 메소드를 사용할 수 있다. 클래스 상속에서와 마찬가지로 구현 객체가 읹터페이스 타입으로 변환되어 있는 상태에서만 강제 타입 변환이 가능하다.
- instanceof 연산자로 좌항의 변수가 참조하는 것이 우항의 객체인지 확인할 수 있다.

> 인터페이스 상속

인터페이스는 클래스와 달리 다중 상속을 허용한다. 하위 인터페이스의 구현 클래스는 하위 인터페이스와 모든 상위 인터페이스들의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 한다. 자동 타입 변환 역시 가능하나, 상위 인터페이스 변수로 변환되었을 경우에는 상위 인터페이스에 선언된 메소드만 사용 가능하고 하위 인터페이스의 메소드는 사용할 수 없다.

> 디폴트 메소드와 인터페이스 확장

- 디폴트 메소드는 인터페이스에 선언된 인스턴스 메소드이기 때문에 구현 객체가 있어야 사용할 수 있다. 인터페이스에서 디폴트 메소드를 허용한 이유는 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서이다. *기존 인터페이스의 이름과 추상 메소드의 변경 없이 디폴트 메소드만 추가할 수 있기 때문이다. 디폴트 메소드는 추상 메소드가 아니기 때문에 구현 클래스에서 실체 메소드를 작성할 필요도 없다. 필요에 따라서 클래스에서 재정의해서 사용할 수도 있다.*
- 만약 부모 인터페이스에 디폴트 메소드가 정의되어 있을 경우, 자식 인터페이스는 다음 세 가지 방법으로 디폴트 메소드를 활용할 수 있다.
  - 디폴트 메소드를 단순히 상속만 받는다.
  - 디폴트 메소드를 재정의해서 실행 내용을 변경한다.
  - 디폴트 메소드를 추상 메소드로 재선언한다. 이 경우 자식 인터페이스를 구현하는 클래스는 이것의 실체 메소드를 가지고 있어야 한다.

## 9. 중첩 클래스와 중첩 인터페이스

> 중첩 클래스와 중첩 인터페이스란?

클래스가 여러 클래스와 관계를 맺는 경우에는 독립적으로 선언하는 것이 좋으나, 특정 클래스와 관계를 맺을 경우에는 관계 클래스를 클래스 내부에 선언하는 것이 좋다. **중첩 클래스(Nested Class)**란 클래스 내부에 선언한 클래스를 말한다. 코드의 복잡성을 줄여주고 두 클래스의 멤버들을 서로 쉽게 접근할 수 있다는 장점이 있다.
```java
class ClassName {
    class NestedClassName {
    }
}
```
인터페이스도 클래스 내부에 선언할 수 있다. 이것을 중첩 인터페아스라고 한다. 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위해 사용한다. 주로 UI프로그래밍에서 이벤트를 처리할 목적으로 많이 활용된다.
```java
class ClassName {
    interface NestedInterfaceName {
    }
}
```

> 중첩 클래스

- 멤버 클래스<br>
  클래스 내부에서 선언되는 중첩 클래스를 멤버 클래스라 한다.
  - 인스턴스 멤버 클래스<br>
    인스턴스 필드와 메소드만 선언 가능하고 정적 필드와 메소드는 선언할 수 없다.
    ```java
    class A{
        class B{...}// A객체를 생성해야만 사용할 수 있다.
    }// 컴파일 시 A$B.class라는 바이트 코드 파일이 생성된다.

    //A클래스 외부에서 B의 객체를 생성하기.
    A a = new A();
    A.B b = a.new B();//
    ```
  - 정적 멤버 클래스<br>
    모든 종류의 필드와 메소드를 선언할 수 있다. A의 객체를 생성하지 않아도 B의 객체를 생성할 수 있다.
    ```java
    class A{
        static class B{...}// A클래스로 바로 접근할 수 있다.
    }

    //A클래스 외부에서 B의 객체를 생성하기.
    A.C c = new A.C();
    ```
- 로컬 클래스
  ```java
  class A {
      void method() {
          class B{..} // method()가 실행될 때만 사용할 수 있다.
          B b = new B(); //로컬클래스 객체 생성.
      }
  }// 컴파일 시 A$1B.class 라는 바이트 코드 파일이 생성된다.
  ```
  - 로컬 클래스는 접근 제한자 및 static을 붙일 수 없다. 내부에는 인스턴스 필드와 메소드만 선언 가능하다.
  - 메소드가 실행될 떼 메소드 내에서 객체를 생성하고 사용해야 한다. 주로 비동기 처리를 위해 스레드 객체를 만들 때 사용한다.

> 중첩 클래스의 접근 제한

- **바깥 필드와 메소드에서 사용 제한<br>**
  멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 바깥 클래스의 필드와 메소드에 사용 제한이 생긴다. 인스턴스 멤버 클래스는 바깥 클래스의 정적 필드의 초기값이나 정적 메소드에서는 객체를 생성할수 없다.
- **멤버 클래스에서의 사용 제한<br>**
  멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 멤버 클래스 내부에서 바깥 클래스의 필드와 메소드를 접근할 때 제한이 생긴다. 정적 멤버 클래스 안에서는 바깥 클래스의 정적 필드와 메소드에만 접근할 수 있다.
- **로컬 클래스에서 사용 제한<br>**
  로컬 클래스 내부에서는 바깥 클래스의 필드나 메소드를 사용하는데 제한이 없다. 메소드의 매개 변수나 로컬 변수를 로컬 클래스에서 사용할 때 문제가 생긴다. 매개변수나 로컬 변수는 메소드 실행이 끝나면 스택 메모리에서 사라지지만 로컬 클래스의 객체는 힙 메모리에 계속 존재한다. 이 경우 로컬 객체가 매개 변수나 로컬 변수를 사용할 경우 문제가 생긴다. 자바는 이 문제를 해결하기 위해 컴파일 시 로컬 클래스에서 사용하는 매개 변수나 로컬 변수의 값을 로컬 클래스 내부에 복사해 두고 사용한다. 그리고 수정으로 인해 값이 달라지는 것을 막기 위해, 로컬 클래스에서 사용하는 매개 변수나 로컬 변수에 final 특성을 부여한다.(자바 8부터) final 키워드의 유무와 상관 없이 final 특성을 갖지만, 키워드가 있을 경우 로컬 클래스의 메소드 내부에 값을 복사하고, 키워드가 없을 경우 로컬 클래스의 필드로 값이 복사된다.
- **중첩 클래스에서 바깥 클래스 참조 얻기**<br>
  클래스 내부에서 this는 객체 자신의 참조이다. 중첩 클래스에서 this는 바깥 클래스가 아니라 중첩 클래스의 객체 참조다. 바깥 클래스의 객체 참조를 얻으려면 this 앞에 바깥클래스 이름과 .연산을 붙여주면 된다.

> 중첩 인터페이스

중첩 인터페이스는 클래스의 멤버로 선언된 인터페이스를 말한다. 클래스 내부에 선언된 중첩 인터페이스를 구현한 객체만 매개값으로 받아 이벤트를 처리하는 경우 쓰인다.

> 익명 객체

익명 객체는 단독으로 생성할 수 없고 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수있다. 익명객체는 필드의 초기값이나 로컬변수의 초기값, 매개변수의 매개값으로 주로 대입된다. UI이벤트 처리 객체나 스레드 객체를 간편하게 생성할 목적으로 많이 활용된다.

- 익명 자식 객체 생성<br>
  부모 타입으로 필드나 변수를 선언하고, 자식 객체를 초기값으로 대입하는 경우, 자식 클래스를 선언하고 자식 객체를 생성한 후 대입해야 한다. 하지만 자식 클래스가 재사용되지 않고 오로지 해당 필드와 변수의 초기값으로만 사용된다면 익명 자식 객체를 생성하는 것이 좋다.
  ```java
  부모 클래스 [필드|변수] = new 부모클래스(매개값,...) {
      //필드 (익명 자식 객체 내부에서만 사용 가능)
      //메소드 (익명 자식 객체 내부에서만 사용 가능)
      //부모 클래스의 메소드 재정의
      //생성자는 XXXX
  };
  ```
  메소드의 매개 변수가 부모 타입일 경우 메소드 호출 코드에서 익명자식 객체를 생성해 매개값으로 대입할 수도 있다.
- 익명 구현 객체 생성<br>
  인터페이스 타입으로 필드나 변수를 선언하고, 구현 객체를 초기값으로 대입하는 경우, 우선 구현 클래스를 선언하고 new 연산자를 이용해 구현 객체를 생성한 후 필드나 로컬 변수에 대입해야 한다. 하지만 구현 클래스가 재사용되지 않고 오로지 초기값으로만 사용된다면 익명 구현 객체를 사용하는 것이 좋다.
- 익명 객체의 로컬 변수 사용<br>
  익명 객체 내부에서는 바깥 클래스의 필드나 메소드는 제한 없이 사용할 수 있다. 메소드의 매개 변수나 로컬 변수를 익명 객체에서 사용할 때는 로컬 클래스와 마찬가지의 문제가 생긴다. 이에 대한 해결법 또한 로컬 클래스와 같다.

 ## 10. 예외 처리

 > 예외와 예외 클래스

 예외는 에러와 달리 예외처리를 통해 프로그램을 종료하지 않고 정상 실행 상태가 유지되도록 할 수 있다. 
 - 일반 예외(Exception)는 컴파일러 체크 예외라고도 하는데, 자바 소스를 컴파일하는 과정에서 예외 처리 코드가 필요한지 검사하기 때문이다. 만약 없다면 컴파일 오류가 발생한다.
 - 실행 예외(Runtime Exception)는 컴파일 과정에서 예외 처리 코드를 검사하지 않는 예외를 말한다. 컴파일 시 예외 처리를 확인하는 차이일 뿐, 두 예외는 모두 예외 처리가 필요하다.
 - 자바에서는 예외를 클래스로 관리한다. JVM은 프로그램 실행 도중 예외가 발생하면 해당 예외 클래스로 객체를 생성한다. 그리고 예외 처리 코드에서 예외 객체를 이용할 수 있도록 해준다. 모든 예외 클래스들은 *java.lang.Exception* 클래스를 상속받는다.
 - 일반 예외는 Exception을 상속받고, 실행 예외는 Exception을 상속받는 RuntimeException을 상속받는 클래스이다. JVM은 RuntiomeException을 상속했는지 여부를 보고 실행 예외를 판단한다.

> 실행 예외

실행 예외는 자바 컴파일러가 체크하지 않기 때문에 개발자가 예외 처리 코드를 삽입해야 한다. 
- **java.lang.NullPointerException**은 자바 프로그램에서 가장빈번하게 발생하며, 객체 참조가 없는 상태, 즉 null 값을 갖는 참조 변수로 객체 접근 연산자은 .을 사용했을 때 발생한다.
- **ArrayIndexOutOfBoundsException**은 배열에서 인덱스 범위를 초과하여 사용할 경우 발생한다.
- **NumberFormatException**은 문자열을 숫하로 변환할 수 있는 정적 메소드인 parseXXX()메소드를 사용 시 숫자로 변환될 수 없는 문자가 표현되어 있다면 발생한다.
- **ClassCastException**은 타입 변환할 수 없는 관계에서 강제 타입 변환을 시도할 경우 발생한다.

> 예외 처리 코드

프로그램에서 예외가 발생했을 경우 프로그램의 갑작스러운 종료를 막고, 정상 실행을 유지할 수 있도록 처리하는 코드를 예외 처리 코드라고 한다. 자바 컴파일러는 일반 예외가 발생할 가능성이 있는 경우 컴파일 오류를 발생시켜 예외 처리 코드를 작성하도록 요구한다. 그러나 실행 예외는 컴파일러가 체크해주지 않기 때문에 예외 처리 코드를 개발자의 경험으로 작성해야 한다.
- 예외 처리 코드는 try-catch-finally 블록을 이용한다. 이 블록은 생성자 내부와 메소드 내부에서 작성되어 일반 예외와 실행 예외가 발생할 경우 예외 처리를 할 수 있도록 해준다.
  ```java
  try {
      //예외 발생 가능 코드
  } catch(예외클래스 e) {//예외 클래스 타입은 try 블록에서 발생된 예외의 종류.
      //예외 처리
  } finally {
      //항상 실행
  }
  ```
  try블록의 코드가 예외 발생 없이 정상 실행되면 finally 블록의 코드를 실행한다. 만약 예외가 발생하면 즉시 실행을 멈추고 catch 블록의 예외 처리 코드를 실행한 뒤 finally 블록의 코드를 실행한다. try와 catch 블록에서 return문을 사용하더라도 finally 블록은 항상 실행된다. finally 블록은 생략 가능하다.

> 예외 종류에 따른 처리 코드

- **다중 catch**<br>
  try 블록 내부는 다양한 종류의 예외가 발생할 수 있다. 이 경우, 발생되는 예외별로 예외 처리 코드를 다르게 하려면 다중 catch 블록을 작성하면 된다. catch 블록의 예외 클래스 타입에 맞는 타입의 예외가 발생하면 그 블록이 실행된다. try 블록에서 하나의 예외가 발생하면 즉시 실행을 멈추기 때문에 단 하나의 catch 블록만 실행된다.
- **catch 순서**<br>
  다중 catch 블록 작성 시, 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야 한다. 예외 발생 시 위에서부터 차례로 검색되기 때문에 상위 예외 클래스의 catch블록이 먼저 있다면 하위 예외 클래스의 catch블록은 실행되지 않는다. 
- **멀티 catch**<br>
  자바7부터 하나의 catch 블록에서 여러 개의 예외를 처리할 수 있도록 멀티 catch 기능이 추가되었다. catch 괄호 안에 동일하게 처리하고 싶은 예외를 |로 연결하면 된다.

> 자동 리소스 닫기

자바 7에서 새로 추가된 *try-with-resources*를 사용하면 예외 발생 여부와 상관없이 사용했던 리소스 객체(각종 입출력 스트림, 서버 소켓, 소켓, 각종 채널)의 close() 메소드를 호출해서 안전하게 리소스를 닫아준다. 리소스는 데이터를 읽고 쓰는 객체이다.
```java
//리소스 객체를 안전하게 닫기 위해 이전까지 썼던 코드
FileInputStream fis = null;
try {
    fis = new FileInputStream("file.txt");
    //...
} catch(IOException e) {
    //...
} finally {
    if(fis != null) {
        try {
            fis.close();
        } catch (IOException e) {}
    }
}// finally 블록에서 다시 try-catch를 사용해서 close()메소드를 예외 처리해야 한다.

//try-with-resources 사용
try(FileInputStream fis = new FileInputStream("file.txt")) {
    //...
} catch(IOException e) {
    //...
}/* try 블록이 정상적으로 실행을 완료했거나 도중에 예외가 발생하게 되면
자동으로 FileInputStream의 close()메소드가 호출된다.
우선 리소스를 닫고 catch 블록을 실행한다.*/
```
- try-with-resources를 사용하기 위해서는, 리소스 객체가 java.lang.AutoCloseable 인터페이스를 구현하고 있어야 한다. AutoCloseable에는 close() 메소드가 정의되어 있는데, 자동으로 호출되는 close()메소드가 이것이다.
- API 도큐먼트에서 AutoCloseable 인터페이스를 찾아 "All Known Implementing Classes:"를 보면 try-with-resources와 함께 사용할 수 있는 리소스가 어떤 것이 있는지 알수 있다.

> 예외 떠넘기기

메소드 내부에서 예외가 발생할 수 있는 코드를 작성할 때 try-catch 블록으로 예외를 처리하는 것이 기본이지만, 경우에 따라서는 *throws 키워드*를 사용해 메소드를 호출한 곳으로 예외를 떠넘길 수도 있다. throws는 메소드 선언부 끝에 작성되어 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠넘기는 역할을 한다. throws 키워드 뒤에는 떠넘길 예외 클래스를 쉼표로 구분해서 나열한다.
```java
리턴타입 메소드명(매개변수,..) throws 예외클래스1, 예외클래스2, .. {
}

리턴타입 메소드명(매개변수,..) throws Exception { 
} //종류별로 나열하지 않고 모든 예외를 간단히 떠넘길 수도 있다.
```
throws 키워드가 붙어있는 메소드는 반드시 try 블록 내에서 호출되어야 한다. 그리고 catch 블록에서 떠넘겨 받은 예외를 처리해야 한다.
```java
public void method1() {
    try {
        method2();//메소드 호출
    } catch(ClassNotFoundException e) {
        //예외 처리 코드
        System.out.println("클래스가 존재하지 않습니다.");
    }
}

public void method2() throws ClassNotFoundException {
    //위 호출한 곳에서 예외 처리
    Class clazz = Class.forName("java.lang.String2");
}

/*method1()에서도 throws로 다시 예외를 떠넘길 수 있다.
이 경우 method1()를 호출하는 곳에서 try-catch 블록을 사용해서 예외 처리 해야 한다.*/
```
자바 API 도큐먼트를 보면 클래스 생성자와 메소드 선언부에 throws 키워드가 붙어있는 경우가 흔히 있다. 이러한 생성자와 메소드를 사용하고 싶다면, 반드시 try-catch 블록으로 예외 처리를 해야 한다.

> 사용자 정의 예외와 예외 발생

자바 표준 API에서 제공하는 예외 클래스만으로는 다양한 종류의 예외를 표현할 수 없다. 애플리케이션 서비스와 관련된 예외를 애플리케이션 예외 또는 사용자 정의 예외라고 한다.
- 사용자 정의 예외 클래스는 Exception을 상속해서 컴파일러가 체크하는 일반 예외로 선언할 수도 있고, RuntimeException을 상속해서 컴파일러가 체크하지 않는 실행 예외로 선언할 수도 있다.
    ```java
    public class XXXException extends [Exception | RuntimeException] {
        public XXXException() {}
        public XXXException(String message) { super(message); }
    }
    ```
  이름은 Exception으로 끝나는 것이 좋다. 필드, 생성자, 메소드 선언들을 포함할 수 있지만 대부분 생성자 선언만을 포함한다. 보통 두개의 생성자를 선언하는데, 하나는 매개 변수가 없는 기본 생성자이고 다른 하나는 예외 발생 원인(예외 메시지)을 전달하기 위해 String 타입의 매개 변수를 갖는 생성자이다. 후자는 상위 클래스의 생성자를 호출하여 예외 메시지를 넘겨준다. 예외 메시지의 용도는 catch 블록의 예외 처리 코드에서 이용하기 위해서이다.
- 코드에서 예외를 발생시키는 방법은 다음과 같다.
  ```java
  throw new XXXException();
  throw new XXXException("메시지");
  ```
  예외 객체를 생성할 때는 둘 중 아무 생성자를 사용해도 되지만 catch 블록에서 예외 메시지가 필요하다면 예외 메시지를 갖는 생성자를 이용해야 한다.
  ```java
  /*예외발생코드를 가지는 메소드는 내부에서 try-catch블록으로 예외를 처리할 수 있지만,
  대부분 throws 키워드로 예외를 떠넘긴다.*/
  public void method() throws XXXException {
      throw new XXXException("메시지");
  }

  //그렇기 때문에 이 메소드를 호출한 곳에서 예외 처리를 해주어야 한다.
  try {
      method();
  } catch(XXXException e) {
      //예외 처리
  }
  ```

> 예외 정보 얻기

try 블록에서 예외가 발생되면 예외 객체는 catch 블록의 매개 변수에서 참조하게 되므로, 매개 변수를 이용하면 예외 객체의 정보를 알 수 있다. 모든 예외 객체들은 Exception 클래스를 상속하기 때문에 Exception이 가지고 있는 메소드들을 호출할 수 있다.
- getMessage() 메소드<br>
  예외를 발생시킬 때 String타입의 메시지를 갖는 생성자를 이용했다면, 메시지는 자동적으로 예외 객체 내부에 저장된다. 메시지는 상세함을 위해 예외 코드를 포함하기도 하는데, 이런 예외 메시지는 catch 블록에서 getMessage() 메소드의 리턴값으로 얻을 수 있다.
  ```java
  try {
      //..
  } catch (Exception e) {
      //예외가 가지고 있는 Message 얻기
      String message = e.getMessage();
  }
  ```
- printStackTrace() 메소드<br>
  예외 발생 코드를 추적해서 모든 콘솔에 출력한다. 어떤 예외가 어디에서 발생했는지 상세하기 출력해주기 때문에 프로그램을 테스트하면서 오류를 찾을 때 활용된다.
  ```java
  try {
      //..
  } catch (Exception e) {
      //예외의 발생 경로를 추적
      e.printStackTrace();
  }
  ```