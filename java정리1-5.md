## 1. 자바 시작하기
> 자바의 특징

자바는 1995년 처음 썬 마이크로시스템즈로부터 발표된 언어이다. 자바는 메모리 및 CPU를 지나치게 만힝 사용하기 때문에 윈도우 프로그래밍 언어로는 부적합하다는 문제점이 있었다. 하지만 인터넷이 활성화되면서 웹 애플리케이션 구축용 언어로 급부상했다. 기업체 및 공공기관의 다양한 서벙 운영체제에서 단 한 번의 작성으로 모든 곳에서 실행 가능한 언어가 자바이다.<br>
- 자바는 이식성이 높은 언어이기 때문에 소스 파일을 수정하지 않아도 자바 실행 환경 (JRE)이 성치되어 있는 모든 운영체제에서 실행 가능하다. 
- 자바는 객체 지향 언어이다. 부품에 해당하는 객체들을 먼저 만들고ㅡ 이것들을 하나씩 조립 및 연결해서 전체 프로그램을 완성하는 기법을 객체 지향 프로그래밍(OOP)이라고 한다.
- 함수적 스타일 코딩을 지원한다. 대용량 데이터의 병렬 처리 그리고 이벤트 지향 프로그래밍에 적합하다. 람다식을 사용하면 컬렉션의 요소를 필터링, 매핑, 집계 처리하는데 쉬워지고, 코드가 간결해진다.
- 메모리를 자동으로 관리한다. 자바는 개발자가 직접 메모리에 접근할 수 없도록 설계되었다. 객체 생성 시 자동적으로 메모리 영역을 찾아서 할당하고, 사용이 완료되면 쓰레기 수집기를 실행시켜 자동적으로 사용하지 않는 객체를 제거시켜준다.
- 자바는 윈도우, 리눅스, 유닉스, 맥 등 다양한 운영체제에서 실행되는 프로그램을 개발할 수 있다. 자바는 다양한 운영체제에서 사용할수 있는 개발 도구와 API를 묶어 Edition 형태로 제공하고 있다.
```
    Java SE - 기본 에디션
    Java EE - 서버용 애플리케이션 개발 에디션
```
- Multi-Thred를 쉽게 구현할 수 있다. 하나의 프로그램이 동시에 여러 가지 작업을 처리해야 할 경우와 대용량 작업을 빨리 처리하기 위해 서브 작업으로 분리해서 병렬처리하려면 멀티 스레디 프로그래밍이 필요하다.
- 동적 로딩을 지원한다. 애플리케이션이 실핼될 때 모든 객체가 생성되지 않고, 객체가 필요한 시점에 클래스를 동적 로딩해서 객체를 생성한다. 따라서 유지보수가 용이하다.
- 막강한 오픈소스 라이브러리가 풍부하다.

> 자바 가상 기계 (JVM)

자바 프로그램은 완전한 기계어가 아닌, 중간 단계의 바이트 코드이기 때문에 이것을 해석하고 실행할 수 있는 가상의 운영체제가 필요하다. 이것이 자바 가상 기계이다. 운영체제별로 프로그램을 실행하고 관리하는 방법이 다르기 때문에, JVM이 운영체제와 자바 프로그램을 중계한다. 따라서 JVM은 운영체제에 맞게 설치되어야 하며, JDK또는 JRE를 설치하면 자동으로 설치된다.
```
                                 소스 파일(*.java)
                                       |
                        컴파일러(javac)->|
                                       |
                              바이트 코드 파일(*.class)
                                       |
                                ---------------
                                |             |
                                |   JVM 구동   |
                                |             |
                             운영체제A         운영체제B
                          A에 맞는 기계어로   B에 맞는 기계어로
                            번역 후 실행      번역 후 실행
```

> 자바 개발 환경 구축
- 자바 개발 도구 JDK 설치 및 환경 변수 설정
- API 도큐먼트. docs.oracle.com/javase/8/docs/api/
> 프로그램 소스 구조
```java
public class Main {
    public static void main(String[] args) {
        System.out.println("hello, welcome to the java world!");
    }
}
```
자바 실행 프로그램은 반드시 class블록과 main() method블록으로 구성되어야 한다. 메소드 블록은 단독으로 작성될 수 없고 항상 클래스 블록 내부에서 작성되어야 한다.<br>
- 클래스: 필드 또는 메소드를 포함하는 블록
- 메소드: 어떤 일을 처리하는 실행문들을 모아 놓은 블록<br>
  
위 코드에서 Main이 클래스 이름이고, 클래스 이름은 마음대로 정할 수 있지만 소스 파일명과 대소문자가 일치해야 한다. 숫자로 시작하거나 공백을 포함할 수 없고, 대문자로 시작해야 한다. 메소드는 클래스처럼 이름과 블록을 가진다. main이 메소드 이름이고, 또한 마음대로 정할 수 있지만 main()메소드 만큼은 다른 이름을 바꾸면 안된다. JVM이 구동 시 제일 먼저 main()메소드를 찾아 실행시키기 때문이다. 메소드 블록에는 실행문이 작성되는데, 실행문 끝에는 반드시 세미콜론(;)을 붙여야 한다.<br>
주석문의 종류는 다음과 같다.
- // : //부터 라인 끝가지 주석으로 처리한다.
- /* ~ */ : /*와 */사이에 있는 모든 범위를 주석으로 처리한다.
- /** ~ */ : 자바 API 도큐먼트 문서에 포함되는 도큐먼트 주석. 도큐먼트 주석은 javadoc.exe 명령어로 API 도큐먼트를 생성하는데 사용된다.

## 2. 변수와 타입
> 변수

변수란 한 가지 타입의 하나의 값을 저장할 수 있는 메모리의 공간을 의미한다. 다음과 같이 변수를 선언할 수 있다.
```java
int age;
double value;
int x, y, z;
```
변수 이름은 메모리 주소에 붙여진 이름이다. 프로그램은 변수 이름을 통해서 메모리 주소에 접근한다.
자바의 변수 명명 규칙은 다음과 같다.
- 첫번째 글자는 문자,$,_ 중 하나여야 한다.
- 영어 대소문자가 구분된다.
- 첫 문자는 영어 소문자로 시작하되, 뒤이어 다른 단어가 붙을 경우 대문자를 첫 문자로 한다.(관례) ex) maxSpeed, carBodyColor
- 길이의 제한은 없으며, 자바 예약어는 사용할수 없다.

소스 코드 내에서 직접 입력된 값을 리터럴(literal)이라고 부른다. 리터럴의 규칙은 다음과 같다.
- 정수 리터럴: 소수점이 없는 정수 리터럴은 10진수, 0으로 시작되면 8진수, 0x,0X로 시작하고 0~9 숫자나 a,b,c,d,e,f,A,B,C,D,E,F로 구성되면 16진수.
- 정수 리터럴을 저장할 수 있는 타입: byte, char, short, int, long
- 실수 리터럴: 소수점이 있는 리터럴은 10진수, E 또는 e가 있는 리터럴은 10진수 지수와 가수로 간주.(5E7 -> 5 * 10의 7승)
- 실수 리터럴을 저장할 수 있는 타입: float, double
- 문자 리터럴: 'A', '한', '\t', '\n' 저장할 수 있는 타입은 char 뿐이다.
  ```
  \가 붙은 문자 리터럴은 escape 문자라고도 하며, 특수한 용도로 사용된다.
  '\t' : 수평 탭
  '\n' : 줄 바꿈
  '\r' : 리턴
  '\"' : "
  '\'' : '
  '\\' : \
  '\u16진수' : 16진수에 해당하는 유니코드
  ```
- 문자열 리터럴: "대한민국", "탭 만큼 이동 \t 합니다." 저장할 수 있는 타입은 String 뿐이다.
- 논리 리터럴: true, false 저장할 수 있는 타입은 boolean 뿐이다.

변수는 초기화가 되어야 읽을 수 있으며, 중괄호{} 블록 내에서 선언되고 사용된다. 중괄호 블록을 사용하는 곳은 클래스, 생성자, 메소드이다.

> 데이터 타입

모든 변수에는 type이 있으며, 이에 따라 저장할 수 있는 값의 종류와 범위가 달라진다.
- 기본(원시: primitve) 타입
  - 정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입을 말한다.
    ```
    정수 | byte     1byte
          char     2byte
          short    2byte
          int      4byte
          long     8byte
    실수 | float    4byte
          double   8byte
    논리 | boolean  1byte
    ```
- 정수 타입(byte, char, short, int, long)
    -  자바는 기본적으로 정수 연산을 int 타입으로 수행한다.
    -  실행 중에 저장할 수 있는 값의 범위를 초과하면 최솟값부터 다시 반복 저장된다.
  - char 타입
    - 자바는 모든 문자를 유니코드로 처리한다. 유니코드는 세계 각국의 문자들을 코드값으로 매핑한 국제 표준 규약이다. 유니코드는 하나의 문자에 대해 하나의 코드값을 부여한다. 유니코드는 0~65535 범위의 2byte 크기를 가진 정수값이다. 0~127까지는 아스키 문자가 할당되어 있고, 44032~55203 까지는 한글 11172글자가 할당되어 있다. **유니코드는 음수가 없기 때문에 char 타입의 변수에는 음수 값을 저장할 수 없다. 저장할 수 있는 값은 0~65535까지 2의 16제곱 개이다.** char 타입 변수에 작은 따옴표로 감싼 문자를 대입하면 해당 문자의 유니코드가 저장된다. 유니코드 정수값을 직접 저장할 수도 있다. char 변수에 저장된 유니코드를 알고 싶다면 char 타입 변수를 int 타입 변수에 저장하면 된다.
        ```java
        ex)
        char c = '\u0041';
        int unicode = c;
        System.out.println(c);

        /*System.out.println()은 변수의 타입이 char이면
        유니코드에 해당하는 문자를 출력한다.*/
        ```
  - String 타입
    - String은 문자열을 저장한다. String은 기본 타입이 아니라 클래스 타입이고, String 변수는 참조 변수이다. 문자열이 변수에 직접 저장되는 것이 아니라, String 객체가 생성되고, String 변수는 String 객체의 번지를 참되하게 된다.
        ```java
        char c = ''; //컴파일 에러
        char c2 = ' '; // 공백(유니코드 32)을 포함해야 한다.
        String str = ""; //String 변수는 빈 문자를 대입해도 괜찮다.
        ```
  - long 타입
    - 일반적으로 int 타입의 저장 범위를 넘어서는 큰 정수를 long 타입 변수에 대입하려면, 정수값 뒤에 L,l을 붙여 컴파일러에게 8byte 정수 데이터임을 알려주어야 한다. 일반적으로 숫자 1과 구분하기 위해 대분자 L을 사용한다.
- 실수 타입(float, double)
    - 메모리 사용 크기는 각각 int와 long의 크기와 같지만, 정수 타입과는 다른 저장방식 때문에 훨씬 더 큰 범위의 값을 저장할 수 있다. 
        ```
        부동 소수점 방식.
        +(부호)  m(가수) X 10의 n제곱(지수)
        가수 m은 0 <= m > 1범위의 실수여야 한다.

        float: 부호(1bit) + 가수(23bit) + 지수(8bit) = 32bit = 4byte
        double: 부호(1bit) + 가수(52bit) + 지수(11bit) = 64bit = 8byte
        ```
    - 자바는 실수 리터럴의 기본 타입을 double로 간주한다. float 타입 변수에 저장하려면 리터럴 뒤에 f,F를 붙여야 한다.
- 논리 타입(boolean)
  - boolean 타입은 두 가지 상태값을 저장할 필요성이 있을 경우에 주로 사용된다.
  
> 타입 변환

- 자동 타입 변환(묵시적)
  - 자동 타입 변환은 프로그램 실행 도중에 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생한다. 단, float 타입의 경우 표현할 수 있는 값의 범위가 long 타입보다 크기 때문에 크기가 더 큰 타입으로 표시된다.
- 강제 타입 변환(명시적, Casting)
  - 간제적으로 큰 데이터 타입을 작은 데이터 타입으로 쪼개어서 저장하는 것. 강제 타입 변환은 캐스팅 연산자 ()를 사용하는데, 괄호 안에 들어가는 타입은 쪼개는 단위이다. 가장 끝에 있는 만큼의 단위만 저장되고 나머지는 버려진다. 실수 타입을 정수 타입으로 캐스팅할 때는 소수점 이하 부분은 버려지고 정수 부분만 저장된다.
  - 강제 타입 변환을 하기 전에 우선 안전하게 값이 보존될 수 있는지 검사하는 것이 좋다.
    ```java
    public class CheckValueBeforeCasting {
        public static void main(String[] args) {
            int i = 128;

            if( (i<Byte.MIN_VALUE) || (i<B?yte.MAX_VALUE)) {
                System.out.println("byte 타입으로 변환할 수 없습니다.");
            } else {
                byte b = (byte) i;
                System.out.println(b);
            }
        }
    }
    //(대문자로 시작되는 타입 이름).MAX_VALUE는 최대값 상수를 얻을 수 있다.
    ```
  - 연산식에서는, 두 피연산자 중 크기가 작은 타입이 크기가 큰 타입으로 자동 변환된 후 연산을 수행한다.
  - 정수 연산의 경우, 4byte보다 작은 타입의 연산은 int타입으로 변환된 후 연산이 수행된다.
  - 실수 연산의 경우, float타입 끼리의 연산의 결과는 float 타입으로 나오지만, 피연산자 중 실수 리터럴이나 double 타입이 있다면 double 타입으로 자동 변환되어 결과도 double 타입으로 산출된다.

## 3. 연산자

> 연산자와 연산식

자바에서, 산술 연산자의 경우는 숫자 타입으로 결과값이 나오고, 비교 연산자와 논리 연산자는 논리 타입(boolean)으로 나온다. 피연산자의 개수에 따라 단항, 이항, 삼항 연산자로 나뉜다.

> 연산의 방향과 우선순위

- 단항, 이항, 삼항 연산자 순으로 우산순위를 가진다.
- 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가진다.

연산의 순서는 연산자 간의 우선순위를 따르며, 우선순위가 같을 경우 왼쪽에서 오른쪽으로 연산을 한다. 단, 단항연산자(++,--,~,!), 부호연산자(+,-), 대입연산자(=,+=,-=,...)는 오른쪽에서 왼쪽으로 연산된다.

> 단항 연산자

- 부호 연산자(+, -)
  - 부호 연산자의 산출 타입은 int 타입이 된다.
    ```java
    short s = 100;
    short result = -s; //컴파일 에러
    int result2 = -s; //int 타입으로 산출된다.
    ```
- 증감 연산자(++, --)
  - boolean 타입을 제외한 모든 기본 타입의 피연산자에 사용할 수 있다. 위치에 따라 산출의 순서가 바뀐다. 
- 논리 부정 연산자(!)
  - boolean 타입에만 사용할 수 있다.
- 비트 반전 연산자(~)
  - 정수 타입의 피연산자에만 사용되며, 부호 비트를 포함한 모든 비트를 반전시킨다. 산출 타입은 int 타입이 된다. 
  - **자바는 정수값을 총 32비트의 이진 문자열로 리턴하는 Integer.toBinaryString() 메소드를 제공한다.** 이 메소드는 앞의 비트가 모두 0이면 0은 생략되고 나머지 문자열을 리턴하기 때문에 총 32개의 문자열을 모두 얻기 위해서는 다음과 같은 메소드가 필요하다.
    ```java
    public static String toBinaryString(int value) {
        String str = Integer.toBinatyString(value);
        while(str.length() < 32) {
            str = "0" + str;
        }
        return str;
    }
    ```
> 이항 연산자

- 산술 연산자(+, -, *, /, %)
  - 산술 연산을 할 때 주의할 점은 연산 후의 산출값이 산출 타입으로 표현 가능한지(크기와 타입 종류 등) 살펴봐야 한다. (단, 자바는 리터럴 간의 연산은 타입 변환 없이 해당 타입으로 계산한다.) 산출 타입으로 표현할 수 없는 값이 산출되었을 경우, 오버플로우가 발생하고 쓰레기값을 얻을 수 있다.
  - / 또는 % 연산을 사용할 때, 좌측 피연산자가 정수 타입일 경우 우측 피연산자는 0을 사용할 수 없다. 컴파일은 되지만, 예외가 발생한다. 자바는 실행 도중 예외가 발생하면 실행을 멈추고 프로그램을 종료한다. 종료되지 않도록 하려면 예외 처리를 해야 한다.
  - 그러나 실수 타입인 0.0 또는 0.0f로 나누면 예외가 발생하지 않고, / 연산의 결과는 Infinity 값을 가지며, % 연산의 결과는 NaN(Not a Number)을 가진다. 이 경우 이 값은 어떤 수와 연산하더라도 Infinity와 NaN이 산출되어 데이터가 엉망이 될 수 있다. 따라서 연산의 결과가 Infinity 또는 NaN 이라면 다음과 같이 연산을 수행하지 못하도록 해야한다.
    ```java
    Double.isInfinite() //매개변수가 Infinity라면 true, 그렇지 않으면 false 리턴
    Double.isNaN() //매개변수가 NaN라면 true, 그렇지 않으면 false 리턴

    if(Double.isInfinite(z) || Double.isNaN(z)) {
        System.out.println("값 산출 불가");
    } else {
        System.out.println(z+2); //조건이 false일 경우에만 연산을 수행
    }
    ```
  - 부동소수점(실수)을 입력받을 때에도 반드시 NaN 검사를 해야 한다. 단, NaN은 != 연산자를 제외한 모든 비교 연산자를 사용할 경우 false값을 리턴한다. 따라서 반드시 Double.isNaN() 메소드를 사용해야 한다.
- 문자열 연결 연산자(+)
  - +연산자는 산술 연산자, 부호 연산자인 동시에 문자열 연결 연산자이기도 하다. 피연산자 중 한쪽이 문자열이면 +연산자는 문자열 연결 연산자로 사용되어 다른 피연산자를 문자열로 반환하고 서로 결합한다.
     ```java
     String str1 = "JDK" + 6.0;     //결과는 "JDK6.0"
     String str2 = "JDK" + 3 + 3.0; //결과는 "JDK33.0"
     String str3 = 3 + 3.0 + "JDK"; //결과는 "6.0JDK"
     ```
- 비교 연산자(<, <=, >, >=, ==, !=)
  - 비교 연산자는 대소 또는 동등을 비교해서 boolean 타입인 true/false를 산출한다. 대소 연산자는 boolean 타입을 제외한 기본 타입에 사용할 수 있고, 동등 연산자는 모든 타입에 사용될 수 있다. 만약 피연산자가 char 타입이면 유니코드 값으로 비교 연산을 수행한다. 비교 연산자 또한 연산 수행 전 타입 변환을 통해 피연산자의 타입을 일치시킨다. 'A' == 65는 int 타입으로 변환되어 65 == 65 로 비교한다. 3 == 3.0에서는 더 큰 타입인 double타입으로 변환되어 3.0 == 3.0 으로 비교한다.
  - 단, 0.1 == 0.1f 와 같은 경우, 이진 포맷의 가수를 사용하는 모든 부동소수점 타입은 값을 정확히 표현할 수 없어서 0.1f는 0.1의 근사값으로 표현되기 때문에 정확한 비교를 할 수 없다. 이 경우 피연산자를 모두 float 타입으로 변환하거나 정수로 변환해서 비교해야 한다.
  - String 타입의 문자열을 비교하는 경우, 대소 연산자를 사용할 수 없고 동등 비교 연산자를 사용할 수 있지만, 문자열이 같은지 다른지를 비교하는 용도로는 사용되지 않는다. 자바는 문자열 리터럴이 동일하자면 동일한 String 객체를 참조하도록 되어 있다. 그래서 아래 코드에서 strVar1과 strVar2는 동일한 String 객체의 번지값을 가지고 있다. 그러나 strVar3은 객체 생성 연산자인 new로 새로운 String 객체의 번지값을 가진다.
    ```java
    String strVar1 = "함형규";
    String strVar2 = "함형규";
    String strVar3 = new String("함형규");

    //strVar1 == strVar2 -> true
    //strVar2 == strVar3 -> false
    ```
  - String 객체가 동일한지와는 상관 없이 문자열만을 비교하고 싶다면, == 연산자 대신에 **equals() 메소드**를 사용해야 한다. 이 메소드는 원본 문자열과 매개값으로 주어진 비교 문자열이 동일한지 비교 후 true/false를 리턴한다.<br>
    *ex) boolean result = str1.equals(str2);*
- 논리 연산자(&&, ||, &, |, ^, !)
  - 논리곱 $$, 논리합 ||, 배타적 논리합 ^, 논리 부정 !
  - 논리 연산자의 피연산자는 boolean 타입만 사용할 수 있다.
  - &&는 앞의 피연산자가 false라면 뒤의 피연산자를 평가하지 않고 바로 false를 산출한다. 반면 &는 두 피연산자를 항상 모두 평가해서 산출 결과를 낸다. ||와 |역시 마찬가지다.
- 비트 연산자(&, |, ^, ~, <<, >>, >>>)
  - 비트 연산자는 데이터를 비트 단위로 연산한다. 즉 0과 1이 피연산자가 된다. 그렇기 때문에 정수 타입만 비트 연산을 할 수 있다.
  - 비트 연산자는 피연산자를 int 타입으로 자동 타입 변환한 후 연산을 수행한다. 따라서 그 결과는 int 타입이 된다.
  - <<, >>> 연산자는 왼쪽 정수의 각 비트를 오른쪽 정수 만큼 왼쪽(오른쪽)으로 이동시키고, 빈자리는 0으로 채워진다.
  - \>> 연산자는, 왼쪽 정수의 각 비트를 오른쪽 정수 만큼 오른쪽으로 이동시키고, 빈자리는 왼쪽 정수의 최상위 부호 비트와 같은 값으로 채워진다.
- 대입 연산자(=, +=, ==, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=)
  - 대입 연산자는 모든 연산자들 중 가장 낮은 연산 순위를 가지고 있다. 또한 연산의 진행 방향은 오른쪽에서 왼쪽이다. <br>  
>삼항 연산자
```java
int score = 95;
char grade = (score>90) ? 'A' : 'B';
/* 위 코드에서 score>90 조건문은 피연산자1이 되어, true일 경우 피연산자2인 'A'를,
   false일 경우 피연산자3인 'B'를 리턴한다.
*/
```

## 4. 조건문과 반복문
> 조건문(if문, switch문)

- if문, if-else문, if-else if-else문
  - 조건식에는 true 또는 false 값을 산출할 수 있는 연산식이나, boolean 변수가 올 수 있다. 조건식이 true이면 블록을 실행하고, false이면 블록을 실행하지 않는다. 조건문과 반복문끼리의 중첩도 가능하다.
  - **Math.random() 메소드**는 0.0 이상, 1.0 미만에 속하는 double 타입의 난수 하나를 리턴한다. 다음과 같이 활용 가능하다.
    ```java
    int num = (int)(Math.random() * n) + 1;
    //num은 1~n까지의 임의의 값을 가진다.
    ```
- switch문
  - 자바 6까지는 switch문의 괄호에 정수 타입 변수나 정수값을 산출하는 연산식만 올 수 있었다. 자바 7부터는 String 타입의 변수도 올 수 있다. 이외는 c 와 같다.

> 반복문(for문, while문, do-while문)

- for문
  - for문의 구조는 c 와 같으며, 주어진 횟수만큼 실행문을 반복 실행할 때 적합하다. 
- while문
  - 조건식에는 boolean 변수나 true/false 값을 산출하는 어떠한 연산식이든 올 수 있다. 이외에는 c 와 같다.
  - **System.in.read() 메소드**는 키보드의 하나의 키 코드를 읽어서 int 타입으로 리턴한다.
  - **System.out.println()** 은 매개값을 출력하고 다음 행으로 이동하지만, **System.out.print()** 은 매개값을 출력만 하고 다음 행으로 이동하지다.
- do-while문
  - 구조는 c 와 같다.
  - 다음과 같이 **Scanner 객체**를 생성하고 **nextLine() 메소드**를 호출하면 콘솔에 입력된 문자열을 한 번에 읽을 수 있다.
    ```java
    import java.util.Scanner; //Scanner 클래스를 사용하기 위해 필요
    Scanner scanner = new Scanner(System.in); //Scanner 객체 생성
    String inputString = scanner.nextLine(); //nextLine() 메소드 호출
    //inputString이 키보드로 입력한 문자열을 얻음
    ```
- break문
  - 중첩된 반복문에서 바깥쪽 반복문까지 종료시키려면, 바깥쪽 반복문에 이름(라벨)을 붙이고, break 이름; 을 사용하면 된다. 이외에는 c 와 같다.
    ```java
    Label1: for (...) {
        for (...) {
            break Label1;
        }
    }
    ```
- continue문
  - c 와 같다.

## 5. 참조 타입
> 데이터 타입 분류

프로그램이 하는 일은 결국 데이터를 처리하는 것이다. 자바의 데이터 타입은 크게 기본 타입 (원시 타입: primitive type)과 참조 타입 (reference type)으로 분류된다. 기본 타입은 위에서 정리한 정수, 실수, 문자, 논리 리터럴을 저장하는 타입을 말한다. 참조 타입이란 객체 (object)의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스 타입을 말한다. 기본 타입으로 선언된 변수는 실제 값을 변수 안에 저장하지만, 참조 타입인 배열, 열거, 클래스, 인터페이스를 이용해서 선언된 변수는 메모리의 번지를 값으로 갖는다. *(변수는 스택 영역에 생성되고 객체는 힙 영역에 생성된다.)*

> 메모리 사용 영역

java.exe로 JVM이 시작되면, JVM은 운영체제에서 할당받은 메모리 영역을 메소드 영역, 힙 영역, 스택 영역으로 구분해서 사용한다.
- 메소드 영역
  - 메소드 영역에는 코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스별로 런타입 상수풀(runtime sonstant pool), 필드(field) 데이터, 메소드(method)데이터, 메소드 코드, 생성자(constrictor) 코드 등을 분류해서 저장한다. 메소드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다.
- 힙 영역
  - 객체와 배열이 생성되는 영역이다. 여기에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다. 참조하는 변수나 필드가 없다면 쓰레기 수집기가 실행되어 힙 영역에서 자동으로 제거한다.
- JVM 스택 영역
  - JVM 스택 영역은 각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 할당된다. JVM 스택은 메소드를 호출할 때마다 프레임(frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)한다. 프레임 내부에는 로컬 변수 스택이 있는데, 기본 타입 변수와 참조 타입 변수가 push되거나 pop된다. 변수가 이 영역에 생성되는 시점은 초기화가 될 때, 즉 최초로 변수에 값이 (참조 타입의 경우 힙 영역의 주소가) 저장될 때이다.

> 참조 변수의 ==, != 연산

기본 타입 변수의 경우 이 연산은 변수의 값을 비교하지만, 참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지를 비교한다. 즉, 주소값을 비교한다.

> null과 NullPointerException

- 참조 타입 변수가 null 값을 가진다는 것은 힙 영역의 객체를 참조하지 않는다는 뜻이다. null로 초기화된 참조 변수는 스택 영역에 생성된다. ==, != 연산으로 참조 타입 변수가 null 값을 가지는지 확인할 수 있다. *ex) (변수 이름) == null*
- 참조 타입 변수가 null을 가지고 있을 경우, 참조할 객체가 없으므로 사용할 수가 없다. 이 경우 NullPointerException 이라는 예외가 발생한다.
  ```java
  int[] intArray = neull; // intArray는 배열 타입 변수로, 참조 타입 변수
  intArray[0] = 10;     //NullPointerException 발생

  String str = null; // String은 클래스 타입으로, 참조 타입
  System.out.println("총 문자수: " + str.length());
  //NyllPointerException 발생
  ```
  
> String 타입

- String 변수는 다음과 같이 선언하고 문자열을 저장한다.
  ```java
  String name;
  name = "함형규";
  String hobby = "자바";
  ```
- 사실 문자열이 직접 변수에 저장되는 것이 아니라, 문자열은 String 객체로 생성되고 변수는 그 객체를 참조한다. 자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어 있다.
  ```java
  String name1 = "함형규";
  String name2 = "함형규";
  //name1과 name2는 동일한 String 객체를 참조한다.
  ```
- 힙 영역에 새로운 객체를 만들 때 사용하는 객체 생성 연산자 new 연산자를 이용해 직접 String 객체를 생성시킬 수도 있다.
  ```java
  String name1 = new String("함형규");
  String name2 = new String("함형규");
  //이 경우 name1과 name2는 서로 다른 String 객체를 참조한다.
  ```
- 참조하는 String 객체에 상관없이 문자열 자체만을 비교할 때는 ==, != 연산자가 아닌 **equals() 메소드**를 사용해야 한다.
- 다음과 같이 String 객체를 참조하였으나, null을 대입함으로써 더이상 String 객체를 참조하지 않도록 할 수도 있다.
  ```java
  String hobby = "여행";
  hobby = null;
  //이 경우 JVM은 참조되지 않게 되는 객체를 쓰레기 취급하고 메모리에서 자동 제거한다.
  ```

> 배열 타입

- 대괄호 []는 배열 변수를 선언하는 기호로 사용되는데, 타입 뒤에 붙을 수도 있고 변수 뒤에 붙을 수도 있다. *ex) int[] intArray; , int intArray[];*<br>
배열 변수는 참조 변수에 속한다. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조하게 된다. 참조할 객체가 없다면 배열 변수는 null값으로 초기화될 수 있다.
- 다음과 같이 배열 항목에 값을 저장할 수 있다. 배열 변수를 미리 선언한 후, 값 목록들이 나중에 결정되는 상황이라면 new 연산자를 사용해서 값 목록을 지정해줘야 한다. 메소드의 매개값이 배열일 경우에도, 반드시 new 연산자를 사용해야 한다.
  ```java
  String[] names = {"함형규", "김자바", "홍길동"};
  //{}안의 값들은 힙 영역에 생성된다.

  String[] names2;
  names2 = {"함", "김", "홍"} // 컴파일 에러

  String[] names3 = null;
  names3 = new String[] {"함형", "김자", "홍길"};
  //new 연산자 사용!

  int add(int[] scores) {...} // 이런 메소드가 있을 경우,
  int result = add({95, 85, 90}); // 컴파일 에러
  int result = add( new int[] {95, 85, 90} );
  ```
- new 연산자로 배열을 처음 생성할 경우, 배열은 자동적으로 기본값으로 초기화된다.
  - byte[], short[], int[] -> 기본값 0
  - char[] -> '\u0000'
  - long[] ->0L
  - float[] ->0.0F, douvle[] -> 0.0
  - boolean[] -> false
  - 클래스[], 인터페이스[] -> null
- 배열의 길이
  - 배열의 길이를 얻으려면 배열 객체의 length 필드를 읽으면 된다. *ex) 배열변수.length;*
- 커맨드 라인
  ```java
  public static void main(String[] args) {
      ...
  }
  ```
  java 클래스로 프로그램을 실행하면 JVM은 길이가 0인 String 배열을 먼저 생성하고, main()메소드가 호출할 때 매개값으로 전달한다. 만약, <br>
  **java MainStringArrayArgument 문자열0 문자열1 ... 문자열 n-1**<br>
  위와 같이 java 클래스 뒤에 공백으로 구분된 문자열 목록을 주고 실행하면, 문자열 목록으로 구성된 String 배열이 생성되고 main() 메소드를 호출할 때 매개값으로 전달된다.<br>
  main()메소드는 String[] args 매개 변수를 통해서 커맨드 라인에서 입력된 데이터의 수(배열의 길이)와 입력된 데이터(배열의 항목 값)을 알 수 있게 된다.
  - **Integer.parseInt("정수로 변환 가능한 문자열") 메소드**는 문자열을 정수로 변환시킨 값을 산출한다.
- 다차원 배열
  - 자바는 2차원 배열을 중첩 배열 방식으로 구현한다.
    ```java
    int[][] scores = new int[2][3];
    ```
    위 코드는 힙 영역의 메모리에 세 개의 배열 객체를 생성한다. 배열 변수인 scores는 길이 2인 배열A를 참조한다. 배열A의 scores[0]은 다시 길이 3인 배열B를 참조한다. scores[1]역시 길이 3인 배열C를 참조한다.
  - 자바는 수학 행렬 구조가 아닌 계단식 구조를 가질 수 있다.
    ```java
    int[][] scores = new int[2][];
    scores[0] = new int[2]; // 0,0 0,1
    scores[1] = new int[3]; // 1,0 1,1 1,2
    //배열 항목의 수는 다음과 같다.
    scores.length    //2
    scores[0].length //2
    scores[1].length //3
    ```
    이런 형태의 배열에서, socores[0][2]는 **ArrayIndexOutOfBoundsException**을 발생시킨다. 배열B 객체의 마지막 인덱스는 1이기 때문이다.<br>
    만약 값 목록이 있다면, 중괄호안에 중괄호를 사용해서 나열하면 된다.
- 객체를 참조하는 배열    
  기본 타입의 배열은 각 항목에 직접 값을 가지고 있지만, 참조 타입(클래스, 인터페이스) 배열은 각 항목에 객체의 번지를 가지고 있다.
- 배열 복사
  배열은 한 번 생성하면 크기를 변경할 수 없기 때문에 더 많은 저장 공간이 필요하다면 보다 큰 배열을 새로 만들고 이전 배열로부터 항목 값들을 복사해야 한다. 배열의 복사는 for문을 사용하는 것과 System.arraycopy()메소드를 사용하는 것이 있다.
  ```java
  //for문으로 복사
  int[] oldIntArray = { 1, 2, 3 };
  int[] newIntArray = new int[5];
  for( int i = 0; i < oldIntArrat.length; i++ ) {
      newIntArray[i] = oldIntArray[i];
  } // newIntArray 에는 1,2,3,0,0이 저장.

  //System.arraycopy()메소드로 복사
  /*System.arraycopy(Object src, int srcPos,
  Object dest, int destPos, int length);*/
  /*순서대로 원본 배열, 원본배열에서 복사할 항목의 시작인덱스,
  새 배열, 붙여 넣을 시작 인덱스, 복사할 개수*/
  String[] oldStrArray = { "java", "array", "copy" };
  String[] newStrArray = new String[5];
  System.arraycopy(oldStrArray, 0, newStrArray, 0, oldStrArray.length);
  //newStrArray에는 "java","array","copy",null,null이 저장.
  ```
  참조 타입 배열의 경우, 복사되는 값이 객체의 번지이므로 새 배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일하다. 이것을 얕은 복사(shallow copy)라고 한다. 반대로 깊은 복사(deep copy)는 참조하는 객체도 별도로 생성하는 것을 말한다.
- 향상된 for문<br>
  자바5부터, 배열 및 컬렉션 객체를 좀 더 쉽게 처리할 목적으로 향상된 for문을 제공한다. 향상된 for문은 반복 실행을 하기 위해 카운터 변수와 증감식을 사용하지 않는다. 배열 및 컬렉션 항목의 개수만큼 반복하고, 자동적으로 for문을 빠져나간다.
  ```java
  int[] scores = {95, 71, 84, 93, 87};
  int sum = 0;
  for (int score : scores) { // 배열에서 꺼낸 항목을 저장할 변수 : 배열
    sum = sum + score; //scores 배열의 길이만큼 실행문 실행
  }//더이상 가져올 항목이 없으면 for문 종료
  ```
> 열거 타입

- 열거 타입 선언
  - 열거 타입을 선언하기 위해서는 먼저 열거 타입의 이름을 정하고 열거 타입 이름으로 소스 파일(.java)을 생성해야 한다. 열거 타입 이름은 관례적으로 단어당 첫 문자를 대문자로 하고 나머지는 소문자로 한다. *ex) Week.java, MemberGrade.java
    ```java
    //Week.java
    public enum Week { // 열거 타입 키워드와 이름
        MONDAY,        //열거 상수들
        TUESDAY,
        WEDNESDAY,
        THURSDAY,
        FRIDAY,
        SATURDAY,
        SUNDAY,
        LOGIN_SUCCES   //여러 단어일 경우 언더바 사용이 관례
    }
    ```
  - 열거 타입도 하나의 데이터 타입이므로 변수를 선언하고 사용해야 한다.<br>
    *ex) Week today;*
  - 열거 상수는 단독으로 사용할 수 는 없고 반드시 열거타입.열거상수로 사용된다. 열거 타입 변수 today는 스택 영역에 생성된다. 이 변수에 저장되는 값은 Week.SUNDAY 열거 상수가 참조하는 객체의 번지이다. 즉 열거 상수 SUNDAY와 변수 today는 서로 같은 Week 객체를 참조하게 된다.<br>
    *ex) Week today = Week.SUNDAY;*
  - 열거 타입도 참조 타입이기 때문에 열거 타입 변수는 null값을 저장할 수 있다<br>
    *ex) Week birthday = null;*
  - 하나의 열거 상수는 하나의 열거 객체로 생성된다. 그리고 메소드 영역에 생성된 열거 상수가 해당 객체를 각각 참조한다.
  - 자바는 컴퓨터의 날짜 및 요일, 시간을 프로그램에서 사용할 수 있도록 하기 위해 **Date, Calendar, LocalDateTime**등의 클래스를 제공한다.
     ```java
     import java.util.Calendar;
     //Calendar클래스는 java.util패키지에 있으므로 import가 필요
     Calendar now = Calendar.getInstance();
     /*calendar 변수를 선언하고 Calendar.getInstance()메소드가 리턴하는
     calendar객체를 얻는다.*/
     int year = now.get(Calendar.YEAR); //년
     int month = now.get(Calendar.MONTH) + 1; //월(1~12)
     int day = now.get(Calendar.DAY_OF_MONTH); //일
     int week = now.get(Calendar.DAY_OF_WEEK); //요일(1~7)(일~토)
     int hour = now.get(Calendar.HOUR); //시간
     int minute = now.get(Calendar.MINUTE); //분
     int second = now.get(Calendar.SECOND); //초
     ```
- 열거 객체의 메소드<br>
  열거 객체는 열거 상수의 문자열을 포함해 여러 데이터와 메소드들을 내부 데이터로 가지고 있다. (모든 열거 타입은 컴파일 시에 Enum 클래스를 상속하게 되어 있다)
  ```java
  Week day1 = Week.SUNDAY; //순번6,
  Week day2 = Week.MONDAY; //순번0이라면,

  String name = day1.name();
  //name()메소드는 열거 객체 내부의 문자열인 "SUNDAY"를 리턴한다.
  int ordinal = day1.ordinal(); //6
  //ordinal()메소드는 전체 열거 객체에서 몇 번째 순번인지를 리턴한다.(0부터)
  int result1 = day1.compareTo(day2); //-6 
  int result2 = day2.compareTo(day1); //6
  //compareTo()메소드는 매개값으로 주어진 열거 객체와의 순번차를 보여준다.
  Week weekDay = Week.valueOf("SATURDAY");
  //valueOf()메소드는 매개값으로 주어지는 문자열과 동일한 문자열을 가지는 열거 객체를 리턴한다.
  Week[] days = Week.values();
  //values()메소드는 열거 타입의 모든 열거 객체들을 배열로 만들어 리턴한다.
  //배열의 인덱스는 열거 객체의 순번과 같고, 각 인덱스 값은 해당 열거 객체 번지이다.
  ```
  
    