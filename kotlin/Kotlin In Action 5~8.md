# Kotlin In Action 5~8
## 5. 람다로 프로그래밍
- 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다. 람다를 사용하면 쉽게 공통 코드 구조를 라이브러리 함수로 뽑아낼 수 있다.
- 수신 객체 지정 람다는 람다 선언을 둘러싸고 있는 환경과는 다른 상황에서 람다 본문을 실행할 수 있다.

- - - -
### 람다 식과 멤버 참조

#### 람다 소개: 코드 블록을 함수 인자로 넘기기
- 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법으로 일련의 동작을 변수에 저장하거나 다른 함수에 넘긴다. 람다 식을 사용하면 함수를 선언할 필요가 없고 코드 블록을 직접 함수 인자로 전달할 수 있다.

#### 람다 식의 문법
- 람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다.
- 람다를 따로 선언해서 변구에 저장할 수도 있다. 하지만 함수에 인자를 넘기면서 바로 람다를 정의하는 경우가 대부분이다.

```kotlin
val sum = ( x: Int, y: Int -> x + y }
println(sum(1, 2))
// 3

{ println(42) } () // 람다 식을 직접 호출해도 된다.
// 42

run { println(42) }
// 42
```
- 코틀린 람다 식은 항상 중괄호로 둘러싸여 있다. 인자 목록 주변에는 괄호가 없다.
- 화살표가 인자 목록과 람다 본문을 구분해준다.
- 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다.
- 라이브러리 함수 run은 인자로 받은 람다를 실행해 준다.

```kotlin
data class Person(val name: String, val age: Int)

val people = listOf(Person("A", 29), Person("B", 31))

// 모두 같은 기능을 한다.
println(people.maxBy({ p: Person -> p.age }))
println(people.maxBy() { p: Person -> p.age })
println(people.maxBy { p: Person -> p.age })
println(people.maxBy() { p -> p.age })
println(people.maxBy { it.age })
println(people.maxBy(Person::age)) // 멤버 참조
// Person(name=B, age=31)
```
- 코틀린에는 함수 호출 시 맨 뒤에 있는 인자가 람다 식이라면 그 람다를 괄호 밖으로 빼낼 수 있다는 문법 관습이 있다.
- 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시 빈 괄호를 없애도 된다.
- 로컬 변수처럼 컴파일러는 람다 파라미터의 타입을 추론할 수 있으므로, 생략 가능하다.
- 람다의 파라미터 이름을 디폴트 이름은 it으로 바꾸면 람다 식을 더 간결하게 만들 수 있다. 람다의 파라미터가 하나뿐이고 그 타입을 파라미터가 추론할 수 있는 경우, it을 바로 쓸 수 있다.

- 람다 본문이 여러 줄로 이뤄진 경우, 본문의 맨 마지막에 있는 식이 람다의 결과 값이 된다.

#### 현재 영역에 있는 변수에 접근 
- 람다를 함수 안에서 정의하면, 함수의 파라미터 뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다. 
- 코틀린에서는 자바와 달리 람다 밖 함수에 있는 파이널이 아닌 변수에 접근할 수 있고, 그 변수를 변경할 수도 있다. 이렇게 람다 안에서 사용하는 외부 변수를 *람다가 포획횐 변수*라고 부른다.
- 단, 람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 함수 로출이 끝난 다음에 로컬 변수가 변경될 수도 있다. 이런 경우 해당 변수를 함수의 내부가 아니라 클래스의 프로퍼티나 전역 프로퍼티 등의 위치로 빼내서 나중에 변수 변화를 살펴볼 수 있게 해야 한다.

#### 멤버 참조
- ::를 사용하는 식을 멤버 참조라고 부른다. 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어 준다. ::는 클래스 이름과 참조하려는 멤버 이름 사이에 위치한다.
- 확장 함수도 멤버 함수와 똑같은 방식으로 참조할 수 있다.
- 참조 대상이 함수인지 프로퍼티인지와는 관계없이 멤버 참조 뒤에는 괄호를 넣으면 안된다.
- 멤버 참조는 그 멤버를 호출하는 람다와 같은 타입이다.
- 최상위에 선언된, 다른 클래스의 멤버가 아닌 함수나 프로퍼티를 참조할 수도 있다. 이런 경우 클래스 이름을 생략하고 ::로 참조를 바로 시작한다.

```kotlin
data class Person(val name: String, val age: Int)
val createPerson = ::Person
val p = createPerson("A", 29)
```
- :: 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다. 클래스 생성 작업을 연기하거나 저장해둘 수 있다.

- 바운드 멤버 참조
```kotlin
val p = Person("D", 34)
val function = Person::age
println(function(p))

val p = Person("D", 34)
val function = p::age // 바운드 멤버 참조
println(function())
```
	- 코틀린 1.0에서는 클래스의 메소드나 프로퍼티에 대한 참조를 얻은 다음에 그 참조를 호출할 때 항상 인스턴스 객체를 제공해야 했다. 
	- 코틀린 1.1부터는 바운드 멤버 참조를 이용하면 멤버 참조를 생성할 때 클래스 인스턴스를 함께 저장한 다음 나중에 그 인스턴스에 대해 멤버를 호출해준다. 따라서 호출 시 수신 대상 객체를 별도로 지정해 줄 필요가 없다. 

- - - -
### 컬렉션 함수형 API
- 함수형 프로그래밍 스타일을 사용하면 컬렉션을 다룰 때 편리하다. 대부분의 작업에 라이브러리 함수를 활용할 수 있다.
- 람다나 다른 함수를 인자로 받거나 함수를 반환하는 함수를 고차 함수(High Order Function)라고 부른다.
- 고차 함수와 단순한 함수를 조합해서 코드를 작성하는 기법을 컴비네이터 패턴이라고 부르고, 컴비네이터 패턴에서 복잡한 연산을 만들기 위해 값이나 함수를 조합할 때 사용하는 고차 함수를 컴비네이터라고 부른다.

#### 필수적인 함수: filter와 map
- 두 함수는 컬렉션을 활용할 때 기반이 되는 함수다. 대부분의 컬렉션 연산을 두 함수를 통해 표현할 수 있다.
- filter 함수는 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모아 새로운 컬렉션을 반환한다. 원소를 변환할 수는 없다.
- map 함수(컬렉션의 맵과 다름)는 주어진 람다를 컬렉션의 각 원소에 저장한 결과를 모아서 새 컬렉션을 만든다. 각 원소는 주어진 함수에 따라 변환된 새로운 컬렉션이다.
- filterKeys와 mapKeys는 맵의 키를 걸러내거나 변환하고, filterValues와 mapValues는 맵의 값을 걸러 내거나 변환한다.

#### all, any, count, find: 컬렉션에 술어 적용
- all 함수는 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단한다.
- any 함수는 컬렉션의 원소 중 하나라도 어떤 조건을 만족하는지 판단한다.
- count 함수는 조건을 만족하는 원소의 개수를 반환한다.
- find 함수는 조건을 만족하는 첫 번째 원소를 반환한다.
- size 함수는 컬렉션을 필터링한 결과의 크기를 가져온다. 조건을 만족하는 모든 원소가 들어가는 중간 컬렉션이 생긴다. 반면 count는 조건을 만족하는 원소의 개수만을 추적하지 조건을 만족하는 원소를 따로 저장하지는 않기 때문에 더 효율적이다.

#### groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경
- groupBy 함수는 특성을 파라미터로 전달하면 컬렉션을 자동으로 구분해서 여러 그룹으로 나눠준다.
- 이 연산의 결과는 컬렉션의 원소를 구분하는 특성이 키이고, 키 값에 따른 각 그룹이 값인 맵이다. 각 그룹은 리스트다. 즉, Map<Int, List<T>>이다.

#### flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리
```kotlin
val strings = listOf("abc", "def")
println(strings.flatMap{ it.toList() })
// [a, b, c, d, e, f]
```
- flatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고(또는 매핑), 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다. (또는 펼친다.)
- toList 함수를 문자열에 적용하면 그 문자열에 속한 모든 문자로 이뤄진 리스트가 만들어진다. map과 toList를 함께 사용하면 문자로 이뤄진 리스트로 이뤄진 리스트가 생긴다. ((a, b, c), (d, e, f))
- flatMap 함수는 이 리스트의 리스트에 들어있던 모든 원소로 이뤄진 단일 리스트를 반환한다.
- 리스트의 리스트가 있는데, 모든 중첩된 리스트의 원소를 한 리스트로 모아야 한다면 flatMap을 사용하면 된다. 그런데 특별히 변환해야 할 내용이 없다면 리스트의 리스트를 평평하게 펼치기만 하는 flatten 함수를 사용하면 된다.

- - - -
### 지연 계산(lazy) 컬렉션 연산
- map이나 filter 같은 함수들은 결과 컬렉션을 즉시 생성한다. 시퀀스를 사용하면 중간 단계마다 컬렉션을 만들지 않고 컬렉션 연산을 연쇄할 수 있다.
- 원본 컬렉션을 asSequence() 로 시퀀스로 변환한 후, 연산 연쇄를 한다. 시퀀스도 컬렉션과 똑같은 API를 제공한다. 연산의 연쇄가 끝나면 다시 컬렉션으로 변환한다.
- 코틀린 지연 계산 시퀀스는 Sequence 인터페이스에서 시작한다. 이 인터페이스는 단지 한 번에 하나씩 열거될 수 있는 원소의 시퀀스를 표현할 뿐이다. Sequence 안에는 iterator라는 단 하나의 메소드가 있다. 이 메소드를 통해 시퀀스로부터 원소 값을 얻을 수 있다.
- 시퀀스의 원소는 필요할 때 비로소 계산된다. 따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할 수 있다.
- 시퀀스 원소를 인덱스를 사용해 접근하는 등의 다른 API 메소드가 필요하다면 시퀀스를 리스트로 변환해야 한다.
- 시퀀스는 연산을 지연 계산하기 때문에 정말 계산을 실행하게 만들려면 최종 시퀀스의 원소를 하나씩 이터레이션하거나 최종 시퀀스를 리스트로 변환해야 한다.

#### 시퀀스 연산 실행: 중간 연산과 최종 연산
- 시퀀스에 대한 연산은 중간 연산과 최종 연산으로 나뉜다. 중간 연산은 다른 시퀀스를 반환하며, 그 시퀀스는 최초 시퀀스의 원소를 변환하는 방법을 안다. 최종 연산은 결과를 반환한다. 결과는 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자 또는 객체다. 
- 즉시 계산은 전체 컬렉션에 연산을 적용하지만, 시퀀스의 지연 계산은 원소를 한번에 하나씩 처리한다. 즉 원소 중 일부의 필요 없는 계산은 이뤄지지 않는다.
- 연산들의 순서를 잘 조합하면, 다른 순서일 때와 결과는 같을지라도 변환의 전체 횟수를 줄일 수 있다. (가령 map과 filter를 한다면, filter를 먼저 하면 부적절한 원소를 제외하기 때문에 전체 변환 횟수를 줄일 수 있다.)
- 자바8의 스트림은 시퀀스와 개념이 같다. 코틀린에서 같은 개념을 따로 구현해 제공하는 이유는 안드로이드 등에서 예전 버전 자바를 사용하는 경우 스트림이 없기 때문이다. 스트림 연산은 코틀린과 다르게 여러 CPU에서 병렬적으로 실행할 수 있다.

#### 시퀀스 만들기
```kotlin
val naturalNumbers = generateSequence(0) { it + 1 }
val numbersTo100 = naturalNumbers.takeWhile { it <= 100 }
// 모든 지연 연산은 sum의 결과를 계산할 때 수행된다.
println(numbersTo100.sum())
// 5050
```
- 컬렉션에 대해 asSequence()를 호출해 시퀀스를 만드는 방법 외에, generateSequence 함수를 사용할 수 있다. 이 함수는 이전의 원소를 인자로 받아 다음 원소를 계산한다.

- - - -
### 자바 함수형 인터페이스 활용
- 코틀린 람다를 자바API에 사용해도 아무 문제가 없다.
- 코틀린은 추상 메소드가 단 하나만 있는 함수형 인터페이스를 인자로 취하는 자바 메소드를 호출할 때 람다를 넘길 수 있게 해준다.
- 자바와 달리 코틀린에는 함수 타입이 존재하므로, 함수를 인자로 받을 필요가 있는 함수는 함수형 인터페이스가 아니라 함수 타입을 인자 타입으로 사용해야 한다. 코틀린 함수를 사용할 때는 코틀린 컴파일러가 코틀린 람다를 함수형 인터페이스로 변환해주지 않는다.

#### 자바 메소드에 람다를 인자로 전달
- 함수형 인터페이스를 인자로 원하는 자바 메소드에 코틀린 람다를 전달할 수 있다. 컴파일러는 자동으로 람다를 익명 구현 인스턴스로 변환해준다.
- 객체를 명시적으로 선언하는 경우 메소드를 호출할 때마다 새로운 객체가 생성된다. 람다는 정의가 들어있는 함수의 변수에 접근하지 않는 람다에 대응하는 무명 객체를 메소드를 호출할 때마다 반복 사용한다.
- 단 람다가 주변 영역의 변수를 포획한다면, 매 호출마다 같은 인스턴스를 사용할 수 없다. 그런 경우 컴파일러는 매번 주변 영역의 변수를 포획한 새로운 인스턴스를 생성해준다.

#### SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경
- SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수다. 컴파일러가 자동으로 람다를 함수형 인터페이스 무명 클래스로 바꾸지 못하는 경우 사용한다.

```kotlin
fun createAllDoneRunnable() : Runnable {
	return Runnable {println("All done!")}
}
createAllDoneRunnable().run()
// All done!
```
- SAM 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같다.
- SAM 생성자는 그 함수형 인터페이스의 유일한 추상 메소드의 본문에 사용할 람다만을 인자로 받아서 함수형 인터페이스를 구현하는 클래스의 인스턴스를 반환한다.
- 함수형 인터페이스의 인스턴스를 반환하는 메소드를 사용하거나, 람다로 생성한 함수형 인터페이스 인스턴스를 변수에 저장하는 경우에 SAM 생성자를 활용할 수 있다.

- 람다에는 무명 객체와 달리 인스턴스 자신을 가리키는 this가 없다. 컴파일러 입장에서 람다는 코드 블록일 뿐이고, 객체가 아니므로 참조할 수가 없다. 람다 안에서 this는 그 람다를 둘러싼 클래스의 인스턴스를 가리킨다.
- 이벤트 리스너가 이벤트를 처리하다가 자기 자신의 리스너 등록을 해제해야 한다면 람다를 사용할 수 없다. 리스너를 해제하는 API 함수에게 this를 넘길 수 없기 때문이다.

- 함수형 인터페이스를 요구하는 메소드를 호출할 때, 대부분의 SAM 변환을 컴파일러가 자동으로 수행하지만, 오버로드한 메소드 중에서 어떤 타입의 메소드를 선택해 람다를 변환해 넘겨줘야 할 지 모호한 경우 명시적으로 SAM 생성자를 적용하면 좋다.

- - - -
### 수신 객체 지정 람다: with와 apply
- with와 apply는 코틀린 표준 라이브러리의 함수다.
- 코틀린 람다는 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 기능을 제공한다. 그런 람다를 수신 객체 지정 람다라고 부른다.

#### with 함수
```kotlin
// 방법 1
fun alphabet(): Stirng {
	val result = StringBuilder()
	for (letter in 'A'..'Z') {
		result.append(letter)
	}
	result.append("\nAll alphabet!")
	return result.toString()
}

// 방법 2
fun alphabet2(): String {
	val stringBuilder = StringBuilder()
	return with(stringBuilder) {
		for (letter in 'A'..'Z') {
			this.append(letter)
		}
		append("\nAll alphabet!")
		this.toString()
	}
}
```
- with는 어떤 객체의 이름을 반복하지 않고도 그 객체에 대해 다양한 연산을 수행할 수 있게 해준다.
- 방법 1은 result를 반복 사용한다.
- with는 파라미터가 2개 있는 함수다. 여기서 첫 번째 파라미터는 stringBuilder이고 두 번째 파라미터는 람다다. 람다를 괄호 밖으로 빼내는 관례를 사용함에 따라 전체 함수 호출이 언어가 제공하는 특별 구문처럼 보인다.
- with 함수는 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다. 인자로 받은 람다 본문에서는 this를 사용해 그 수신 객체에 접근할 수 있다.
- this와 .을 사용하지 않고 프로퍼티나 메소드 이름만 사용해도 수신 객체의 멤버에 접근할 수 있다.
- with에게 인자로 넘긴 객체의 클래스와 with를 사용하는 코드가 들어있는 클래스 안에 이름이 같은 메소드가 있을 경우, this참조 앞에 레이블을 붙이면 호출하고 싶은 메소드를 명확하게 정할 수 있다. (this@OuterClass.toString())
- with가 반환하는 값은 람다 코드를 실행한 결과이며, 그 결과는 람다 식의 본문에 있는 마지막 식의 값이다.

#### apply 함수
```kotlin
fun alphabet() = StringBuilder().apply {
	for (letter in 'A'..'Z') {
		append(letter)
	}
	append("\nAll alphabet!")
}.toString()
```
- apply는 with와 같지만, 항상 자신에게 전달된 객체(수신 객체)를 반환한다.
- apply는 확장 함수로 정의되어 있다. apply의 수신 객체가 전달받은 람다의 수신 객체가 된다.
- apply 함수는 객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화해야 하는 경우 유용하다. 자바의 Builder 객체와 담당하는 역할이 같지만, 코틀린에서는 어떤 클래스가 정의되어 있는 라이브러리의 지원 없이도 그 클래스의 인스턴스에 대해 apply를 활용할 수 있다.

- - - -
### 요약
- 람다를 사용하면 코드 조각을 다른 함수에게 인자로 넘길 수 있다.
- 코틀린에서는 람다가 함수 인자인 경우 괄호 밖으로 람다를 빼낼 수 있고, 람다의 인자가 단 하나뿐인 경우 인자 이름을 지정하지 않고 it이라는 디폴트 이름으로 부를 수 있다.
- 람다 안에 있는 코드는 그 람다가 들어있는 바깥 함수의 변수를 읽거나 쓸 수 있다.
- 메소드, 생성자, 프로퍼티의 이름 앞에 ::을 붙이면 각각에 대한 참조를 만들 수 있다. 이 참조를 람다 대신 다른 함수에게 넘길 수 있다.
- filter, map, all, any 등의 함수를 활용하면 컬렉션에 대한 대부분의 연산을 직접 원소를 이터레이션하지 않고 수행할 수 있다.
- 시퀀스롤 사용하면 지연 연산을 사용할 수 있다.
- 함수형 인터페이스를 인자로 받는 자바 함수를 호출할 경우 람다를 대신 인지로 넘길 수 있다.
- 수신 객체 지정 람다를 사용하면 람다 안에서 미리 정해둔 수신 객체의 메소드를 직접 호출할 수 있다.
- 표준 라이브러리의 with 함수를 사용하면 어떤 객체에 대한 참조를 반복해서 언급하지 않으면서 그 객체의 메소드를 호출할 수 있다. apply 를 사용하면 어떤 객체라도 빌더 스타일의 API를 사용해 생성하고 초기화할 수 있다.












