# Kotlin In Action 5~8
## 5. 람다로 프로그래밍
- 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다. 람다를 사용하면 쉽게 공통 코드 구조를 라이브러리 함수로 뽑아낼 수 있다.
- 수신 객체 지정 람다는 람다 선언을 둘러싸고 있는 환경과는 다른 상황에서 람다 본문을 실행할 수 있다.

- - - -
### 람다 식과 멤버 참조

#### 람다 소개: 코드 블록을 함수 인자로 넘기기
- 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법으로 일련의 동작을 변수에 저장하거나 다른 함수에 넘긴다. 람다 식을 사용하면 함수를 선언할 필요가 없고 코드 블록을 직접 함수 인자로 전달할 수 있다.

#### 람다 식의 문법
- 람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다.
- 람다를 따로 선언해서 변구에 저장할 수도 있다. 하지만 함수에 인자를 넘기면서 바로 람다를 정의하는 경우가 대부분이다.

```kotlin
val sum = ( x: Int, y: Int -> x + y }
println(sum(1, 2))
// 3

{ println(42) } () // 람다 식을 직접 호출해도 된다.
// 42

run { println(42) }
// 42
```
- 코틀린 람다 식은 항상 중괄호로 둘러싸여 있다. 인자 목록 주변에는 괄호가 없다.
- 화살표가 인자 목록과 람다 본문을 구분해준다.
- 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다.
- 라이브러리 함수 run은 인자로 받은 람다를 실행해 준다.

```kotlin
data class Person(val name: String, val age: Int)

val people = listOf(Person("A", 29), Person("B", 31))

// 모두 같은 기능을 한다.
println(people.maxBy({ p: Person -> p.age }))
println(people.maxBy() { p: Person -> p.age })
println(people.maxBy { p: Person -> p.age })
println(people.maxBy() { p -> p.age })
println(people.maxBy { it.age })
println(people.maxBy(Person::age)) // 멤버 참조
// Person(name=B, age=31)
```
- 코틀린에는 함수 호출 시 맨 뒤에 있는 인자가 람다 식이라면 그 람다를 괄호 밖으로 빼낼 수 있다는 문법 관습이 있다.
- 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시 빈 괄호를 없애도 된다.
- 로컬 변수처럼 컴파일러는 람다 파라미터의 타입을 추론할 수 있으므로, 생략 가능하다.
- 람다의 파라미터 이름을 디폴트 이름은 it으로 바꾸면 람다 식을 더 간결하게 만들 수 있다. 람다의 파라미터가 하나뿐이고 그 타입을 파라미터가 추론할 수 있는 경우, it을 바로 쓸 수 있다.

- 람다 본문이 여러 줄로 이뤄진 경우, 본문의 맨 마지막에 있는 식이 람다의 결과 값이 된다.

#### 현재 영역에 있는 변수에 접근 
- 람다를 함수 안에서 정의하면, 함수의 파라미터 뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다. 
- 코틀린에서는 자바와 달리 람다 밖 함수에 있는 파이널이 아닌 변수에 접근할 수 있고, 그 변수를 변경할 수도 있다. 이렇게 람다 안에서 사용하는 외부 변수를 *람다가 포획횐 변수*라고 부른다.
- 단, 람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 함수 로출이 끝난 다음에 로컬 변수가 변경될 수도 있다. 이런 경우 해당 변수를 함수의 내부가 아니라 클래스의 프로퍼티나 전역 프로퍼티 등의 위치로 빼내서 나중에 변수 변화를 살펴볼 수 있게 해야 한다.

#### 멤버 참조
- ::를 사용하는 식을 멤버 참조라고 부른다. 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어 준다. ::는 클래스 이름과 참조하려는 멤버 이름 사이에 위치한다.
- 확장 함수도 멤버 함수와 똑같은 방식으로 참조할 수 있다.
- 참조 대상이 함수인지 프로퍼티인지와는 관계없이 멤버 참조 뒤에는 괄호를 넣으면 안된다.
- 멤버 참조는 그 멤버를 호출하는 람다와 같은 타입이다.
- 최상위에 선언된, 다른 클래스의 멤버가 아닌 함수나 프로퍼티를 참조할 수도 있다. 이런 경우 클래스 이름을 생략하고 ::로 참조를 바로 시작한다.

```kotlin
data class Person(val name: String, val age: Int)
val createPerson = ::Person
val p = createPerson("A", 29)
```
- :: 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다. 클래스 생성 작업을 연기하거나 저장해둘 수 있다.

- 바운드 멤버 참조
```kotlin
val p = Person("D", 34)
val function = Person::age
println(function(p))

val p = Person("D", 34)
val function = p::age // 바운드 멤버 참조
println(function())
```
	- 코틀린 1.0에서는 클래스의 메소드나 프로퍼티에 대한 참조를 얻은 다음에 그 참조를 호출할 때 항상 인스턴스 객체를 제공해야 했다. 
	- 코틀린 1.1부터는 바운드 멤버 참조를 이용하면 멤버 참조를 생성할 때 클래스 인스턴스를 함께 저장한 다음 나중에 그 인스턴스에 대해 멤버를 호출해준다. 따라서 호출 시 수신 대상 객체를 별도로 지정해 줄 필요가 없다. 

- - - -
### 컬렉션 함수형 API
- 함수형 프로그래밍 스타일을 사용하면 컬렉션을 다룰 때 편리하다. 대부분의 작업에 라이브러리 함수를 활용할 수 있다.
- 람다나 다른 함수를 인자로 받거나 함수를 반환하는 함수를 고차 함수(High Order Function)라고 부른다.
- 고차 함수와 단순한 함수를 조합해서 코드를 작성하는 기법을 컴비네이터 패턴이라고 부르고, 컴비네이터 패턴에서 복잡한 연산을 만들기 위해 값이나 함수를 조합할 때 사용하는 고차 함수를 컴비네이터라고 부른다.

#### 필수적인 함수: filter와 map
- 두 함수는 컬렉션을 활용할 때 기반이 되는 함수다. 대부분의 컬렉션 연산을 두 함수를 통해 표현할 수 있다.
- filter 함수는 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모아 새로운 컬렉션을 반환한다. 원소를 변환할 수는 없다.
- map 함수(컬렉션의 맵과 다름)는 주어진 람다를 컬렉션의 각 원소에 저장한 결과를 모아서 새 컬렉션을 만든다. 각 원소는 주어진 함수에 따라 변환된 새로운 컬렉션이다.
- filterKeys와 mapKeys는 맵의 키를 걸러내거나 변환하고, filterValues와 mapValues는 맵의 값을 걸러 내거나 변환한다.

#### all, any, count, find: 컬렉션에 술어 적용
- all 함수는 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단한다.
- any 함수는 컬렉션의 원소 중 하나라도 어떤 조건을 만족하는지 판단한다.
- count 함수는 조건을 만족하는 원소의 개수를 반환한다.
- find 함수는 조건을 만족하는 첫 번째 원소를 반환한다.
- size 함수는 컬렉션을 필터링한 결과의 크기를 가져온다. 조건을 만족하는 모든 원소가 들어가는 중간 컬렉션이 생긴다. 반면 count는 조건을 만족하는 원소의 개수만을 추적하지 조건을 만족하는 원소를 따로 저장하지는 않기 때문에 더 효율적이다.

#### groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경
- groupBy 함수는 특성을 파라미터로 전달하면 컬렉션을 자동으로 구분해서 여러 그룹으로 나눠준다.
- 이 연산의 결과는 컬렉션의 원소를 구분하는 특성이 키이고, 키 값에 따른 각 그룹이 값인 맵이다. 각 그룹은 리스트다. 즉, Map<Int, List<T>>이다.

#### flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리
```kotlin
val strings = listOf("abc", "def")
println(strings.flatMap{ it.toList() })
// [a, b, c, d, e, f]
```
- flatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고(또는 매핑), 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다. (또는 펼친다.)
- toList 함수를 문자열에 적용하면 그 문자열에 속한 모든 문자로 이뤄진 리스트가 만들어진다. map과 toList를 함께 사용하면 문자로 이뤄진 리스트로 이뤄진 리스트가 생긴다. ((a, b, c), (d, e, f))
- flatMap 함수는 이 리스트의 리스트에 들어있던 모든 원소로 이뤄진 단일 리스트를 반환한다.
- 리스트의 리스트가 있는데, 모든 중첩된 리스트의 원소를 한 리스트로 모아야 한다면 flatMap을 사용하면 된다. 그런데 특별히 변환해야 할 내용이 없다면 리스트의 리스트를 평평하게 펼치기만 하는 flatten 함수를 사용하면 된다.

- - - -
### 지연 계산(lazy) 컬렉션 연산
- map이나 filter 같은 함수들은 결과 컬렉션을 즉시 생성한다. 시퀀스를 사용하면 중간 단계마다 컬렉션을 만들지 않고 컬렉션 연산을 연쇄할 수 있다.
- 원본 컬렉션을 asSequence() 로 시퀀스로 변환한 후, 연산 연쇄를 한다. 시퀀스도 컬렉션과 똑같은 API를 제공한다. 연산의 연쇄가 끝나면 다시 컬렉션으로 변환한다.
- 코틀린 지연 계산 시퀀스는 Sequence 인터페이스에서 시작한다. 이 인터페이스는 단지 한 번에 하나씩 열거될 수 있는 원소의 시퀀스를 표현할 뿐이다. Sequence 안에는 iterator라는 단 하나의 메소드가 있다. 이 메소드를 통해 시퀀스로부터 원소 값을 얻을 수 있다.
- 시퀀스의 원소는 필요할 때 비로소 계산된다. 따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할 수 있다.
- 시퀀스 원소를 인덱스를 사용해 접근하는 등의 다른 API 메소드가 필요하다면 시퀀스를 리스트로 변환해야 한다.
- 시퀀스는 연산을 지연 계산하기 때문에 정말 계산을 실행하게 만들려면 최종 시퀀스의 원소를 하나씩 이터레이션하거나 최종 시퀀스를 리스트로 변환해야 한다.

#### 시퀀스 연산 실행: 중간 연산과 최종 연산
- 시퀀스에 대한 연산은 중간 연산과 최종 연산으로 나뉜다. 중간 연산은 다른 시퀀스를 반환하며, 그 시퀀스는 최초 시퀀스의 원소를 변환하는 방법을 안다. 최종 연산은 결과를 반환한다. 결과는 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자 또는 객체다. 
- 즉시 계산은 전체 컬렉션에 연산을 적용하지만, 시퀀스의 지연 계산은 원소를 한번에 하나씩 처리한다. 즉 원소 중 일부의 필요 없는 계산은 이뤄지지 않는다.
- 연산들의 순서를 잘 조합하면, 다른 순서일 때와 결과는 같을지라도 변환의 전체 횟수를 줄일 수 있다. (가령 map과 filter를 한다면, filter를 먼저 하면 부적절한 원소를 제외하기 때문에 전체 변환 횟수를 줄일 수 있다.)
- 자바8의 스트림은 시퀀스와 개념이 같다. 코틀린에서 같은 개념을 따로 구현해 제공하는 이유는 안드로이드 등에서 예전 버전 자바를 사용하는 경우 스트림이 없기 때문이다. 스트림 연산은 코틀린과 다르게 여러 CPU에서 병렬적으로 실행할 수 있다.

#### 시퀀스 만들기
```kotlin
val naturalNumbers = generateSequence(0) { it + 1 }
val numbersTo100 = naturalNumbers.takeWhile { it <= 100 }
// 모든 지연 연산은 sum의 결과를 계산할 때 수행된다.
println(numbersTo100.sum())
// 5050
```
- 컬렉션에 대해 asSequence()를 호출해 시퀀스를 만드는 방법 외에, generateSequence 함수를 사용할 수 있다. 이 함수는 이전의 원소를 인자로 받아 다음 원소를 계산한다.

- - - -
### 자바 함수형 인터페이스 활용
- 코틀린 람다를 자바API에 사용해도 아무 문제가 없다.
- 코틀린은 추상 메소드가 단 하나만 있는 함수형 인터페이스를 인자로 취하는 자바 메소드를 호출할 때 람다를 넘길 수 있게 해준다.
- 자바와 달리 코틀린에는 함수 타입이 존재하므로, 함수를 인자로 받을 필요가 있는 함수는 함수형 인터페이스가 아니라 함수 타입을 인자 타입으로 사용해야 한다. 코틀린 함수를 사용할 때는 코틀린 컴파일러가 코틀린 람다를 함수형 인터페이스로 변환해주지 않는다.

#### 자바 메소드에 람다를 인자로 전달
- 함수형 인터페이스를 인자로 원하는 자바 메소드에 코틀린 람다를 전달할 수 있다. 컴파일러는 자동으로 람다를 익명 구현 인스턴스로 변환해준다.
- 객체를 명시적으로 선언하는 경우 메소드를 호출할 때마다 새로운 객체가 생성된다. 람다는 정의가 들어있는 함수의 변수에 접근하지 않는 람다에 대응하는 무명 객체를 메소드를 호출할 때마다 반복 사용한다.
- 단 람다가 주변 영역의 변수를 포획한다면, 매 호출마다 같은 인스턴스를 사용할 수 없다. 그런 경우 컴파일러는 매번 주변 영역의 변수를 포획한 새로운 인스턴스를 생성해준다.

#### SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경
- SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수다. 컴파일러가 자동으로 람다를 함수형 인터페이스 무명 클래스로 바꾸지 못하는 경우 사용한다.

```kotlin
fun createAllDoneRunnable() : Runnable {
	return Runnable {println("All done!")}
}
createAllDoneRunnable().run()
// All done!
```
- SAM 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같다.
- SAM 생성자는 그 함수형 인터페이스의 유일한 추상 메소드의 본문에 사용할 람다만을 인자로 받아서 함수형 인터페이스를 구현하는 클래스의 인스턴스를 반환한다.
- 함수형 인터페이스의 인스턴스를 반환하는 메소드를 사용하거나, 람다로 생성한 함수형 인터페이스 인스턴스를 변수에 저장하는 경우에 SAM 생성자를 활용할 수 있다.

- 람다에는 무명 객체와 달리 인스턴스 자신을 가리키는 this가 없다. 컴파일러 입장에서 람다는 코드 블록일 뿐이고, 객체가 아니므로 참조할 수가 없다. 람다 안에서 this는 그 람다를 둘러싼 클래스의 인스턴스를 가리킨다.
- 이벤트 리스너가 이벤트를 처리하다가 자기 자신의 리스너 등록을 해제해야 한다면 람다를 사용할 수 없다. 리스너를 해제하는 API 함수에게 this를 넘길 수 없기 때문이다.

- 함수형 인터페이스를 요구하는 메소드를 호출할 때, 대부분의 SAM 변환을 컴파일러가 자동으로 수행하지만, 오버로드한 메소드 중에서 어떤 타입의 메소드를 선택해 람다를 변환해 넘겨줘야 할 지 모호한 경우 명시적으로 SAM 생성자를 적용하면 좋다.

- - - -
### 수신 객체 지정 람다: with와 apply
- with와 apply는 코틀린 표준 라이브러리의 함수다.
- 코틀린 람다는 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 기능을 제공한다. 그런 람다를 수신 객체 지정 람다라고 부른다.

#### with 함수
```kotlin
// 방법 1
fun alphabet(): Stirng {
	val result = StringBuilder()
	for (letter in 'A'..'Z') {
		result.append(letter)
	}
	result.append("\nAll alphabet!")
	return result.toString()
}

// 방법 2
fun alphabet2(): String {
	val stringBuilder = StringBuilder()
	return with(stringBuilder) {
		for (letter in 'A'..'Z') {
			this.append(letter)
		}
		append("\nAll alphabet!")
		this.toString()
	}
}
```
- with는 어떤 객체의 이름을 반복하지 않고도 그 객체에 대해 다양한 연산을 수행할 수 있게 해준다.
- 방법 1은 result를 반복 사용한다.
- with는 파라미터가 2개 있는 함수다. 여기서 첫 번째 파라미터는 stringBuilder이고 두 번째 파라미터는 람다다. 람다를 괄호 밖으로 빼내는 관례를 사용함에 따라 전체 함수 호출이 언어가 제공하는 특별 구문처럼 보인다.
- with 함수는 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다. 인자로 받은 람다 본문에서는 this를 사용해 그 수신 객체에 접근할 수 있다.
- this와 .을 사용하지 않고 프로퍼티나 메소드 이름만 사용해도 수신 객체의 멤버에 접근할 수 있다.
- with에게 인자로 넘긴 객체의 클래스와 with를 사용하는 코드가 들어있는 클래스 안에 이름이 같은 메소드가 있을 경우, this참조 앞에 레이블을 붙이면 호출하고 싶은 메소드를 명확하게 정할 수 있다. (this@OuterClass.toString())
- with가 반환하는 값은 람다 코드를 실행한 결과이며, 그 결과는 람다 식의 본문에 있는 마지막 식의 값이다.

#### apply 함수
```kotlin
fun alphabet() = StringBuilder().apply {
	for (letter in 'A'..'Z') {
		append(letter)
	}
	append("\nAll alphabet!")
}.toString()
```
- apply는 with와 같지만, 항상 자신에게 전달된 객체(수신 객체)를 반환한다.
- apply는 확장 함수로 정의되어 있다. apply의 수신 객체가 전달받은 람다의 수신 객체가 된다.
- apply 함수는 객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화해야 하는 경우 유용하다. 자바의 Builder 객체와 담당하는 역할이 같지만, 코틀린에서는 어떤 클래스가 정의되어 있는 라이브러리의 지원 없이도 그 클래스의 인스턴스에 대해 apply를 활용할 수 있다.

- - - -
### 요약
- 람다를 사용하면 코드 조각을 다른 함수에게 인자로 넘길 수 있다.
- 코틀린에서는 람다가 함수 인자인 경우 괄호 밖으로 람다를 빼낼 수 있고, 람다의 인자가 단 하나뿐인 경우 인자 이름을 지정하지 않고 it이라는 디폴트 이름으로 부를 수 있다.
- 람다 안에 있는 코드는 그 람다가 들어있는 바깥 함수의 변수를 읽거나 쓸 수 있다.
- 메소드, 생성자, 프로퍼티의 이름 앞에 ::을 붙이면 각각에 대한 참조를 만들 수 있다. 이 참조를 람다 대신 다른 함수에게 넘길 수 있다.
- filter, map, all, any 등의 함수를 활용하면 컬렉션에 대한 대부분의 연산을 직접 원소를 이터레이션하지 않고 수행할 수 있다.
- 시퀀스롤 사용하면 지연 연산을 사용할 수 있다.
- 함수형 인터페이스를 인자로 받는 자바 함수를 호출할 경우 람다를 대신 인지로 넘길 수 있다.
- 수신 객체 지정 람다를 사용하면 람다 안에서 미리 정해둔 수신 객체의 메소드를 직접 호출할 수 있다.
- 표준 라이브러리의 with 함수를 사용하면 어떤 객체에 대한 참조를 반복해서 언급하지 않으면서 그 객체의 메소드를 호출할 수 있다. apply 를 사용하면 어떤 객체라도 빌더 스타일의 API를 사용해 생성하고 초기화할 수 있다.

## 6. 코틀린 타입 시스템

- - - -
### 널 가능성
- 널 가능성은 NullPointerException 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다. 
- 코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것이다.

#### 널이 될 수 있는 타입
- 코틀린은 널이 될 수 있는 타입을 명시적으로 지원한다. 
- 모든 타입은 기본적으로 널이 될 수 없으며, 프로퍼티나 변수가 널이 될 수 있게 하려면 타입 이름 뒤에 ?를 명시해야 한다.
- 널이 될 수 있는 타입의 변수가 있다면 메소드를 직접 호출할 수 없는 등 그에 대해 수행할 수 있는 연산이 제한된다.
- 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다.
- 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.
- 널이 될 수 있는 타입의 값은 null 과 비교할 수 있다. 일단 null과 비교하고 나면 컴파일러는 그 사실을 기억하고, null이 아님이 확실한 영역에서는 해당 값을 널이 될 수 없는 타입의 값처럼 사용할 수 있다.

#### 타입의 의미
- 타입은 분류로, 타입은 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.
- 자바에서 String 타입의 변수에는 String이나 null이라는 두 종류의 값이 들어갈 수 있다. 하지만 두 종류의 값은 서로 완전히 다르고 사용할 수 있는 연산도 다르다. 자바의 타입 시스템은 널을 제대로 다루지 못한다.
	- 자바의 애노테이션을 활용하면 널 문제를 해결할 수 있지만, 표준 컴파일 절차가 아니기 때문에 일관성 있게 적용된다는 보장을 할 수 없다. 또한 모든 상황에 애노테이션을 추가하는 일도 쉽지 않다.
	- null 값을 절대 쓰지 않고 자바 8의 Optional 타입 등의 null을 감싸는 특별한 래퍼 타입을 활용할 수 있다. Optional은 어떤 값이 정의되거나 정의되지 않을 수 있음을 표현하는 타입이다. 하지만 코드가 지저분해지고 성능이 저하된다.
- 코틀린에서는 널이 될 수 있는 타입과 없는 타입을 컴파일 시점에 구분하여, 별도의 실행 시점 부가 비용이 들지 않으면서 이런 문제를 해결한다.

#### 안전한 호출 연산자: ?.
- ?.은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.
- 호출하려는 값이 null이 아니라면 ?.은 일반 메소드 호출처럼 작동한다. null이라면 이 호출은 무시되고 null이 결과 값이 된다. 즉, 안전한 호출의 결과 타입도 널이 될 수 있는 타입이다.
- 메소드 호출 뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다. 
- 객체 그래프에서 널이 될 수 있는 중간 객체가 여럿 있다면 한 식 안에서 안전한 호출을 연쇄해서 함께 사용하면 편하다.

#### 엘비스 연산자: ?:
```kotlin
fun foo(s: String?) {
	val t: String = s ?: ""
// s가 널이라면 결과는 빈 문자열이다.
}
```
- 코틀린은 null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 엘비스 연산자(널 복합 연산자)를 제공한다. 
- 이 연산자는 이하 연산자로, 좌항을 계산한 값이 널인지 검사한다. 좌항 값이 널이 아니면 좌항 값을 결과로 하고, 널이면 우항 값을 결과로 한다.

- 코틀린에서는 return이나 throw등의 연산도 식이다. 따라서 엘비스 연산자의 우항에도 이 연산을 넣을 수 있다. 이런 경우 연산자의 좌항이 널이면 함수가 즉시 어떤 값을 반환하거나 예외를 던진다. 이런 패턴은 함수의 전제 조건을 검사하는 경우 특히 유용하다.

#### 안전한 캐스트: as?
- 자바와 마찬가지로, 대상 값을 as로 지정한 타입으로 바꿀 수 없으면 ClassCastException이 발생한다.
- as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다. 값을 대상 타입으로 변환할 수 없으면 null을 반환한다.
- 안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다.

#### 널 아님 단언: !!
- 널 아님 단언은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구다.
- !!를 사용하면 어떤 값이든 널이 될 수 없는 타입으로 강제로 바꿀 수 있다. 
- 널에 대해 !!를 적용하면 NullPointerException이 발생한다.
- !!은 컴파일러가 검증할 수 없는 단언이다. 예외가 발생할 경우 위험하므로 다른 방법을 사용하는 것이 낫다.
- 어떤 함수가 값이 널인지 검사한 다음에 다른 함수를 호출한다고 해도 컴파일러는 호출된 함수 안에서 안전하게 그 값을 사용할 수 있음을 인식할 수 없다. 하지만 이런 경우 호출된 함수가 언제나 다른 함수에서 널이 아닌 값을 전달받는다는 사실이 분명하다면 굳이 널 검사를 다시 수행하기보다는 널 아님 단언문을 사용하는 것이 더 낫다.

#### let 함수
- let 함수를 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 한꺼번에 처리할 수 있다.
- let함수는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다. 널이 될 수 있는 값에 대해 안전한 호출 구문을 사용해 let을 호출하되 널이 될 수 없는 타입을 인자로 받는 람다를 let에 전달한다. 즉 let을 안전하게 호출하면 수신 긱체가 널이 아닌 경우에만 람다를 실행해준다.
- let 함수는 널이 될 수 있는 값을 널이 아닌 값만 인자로 받는 함수에 넘기는 경우에 유용하게 쓰일 수 있다.

```kotlin
val person: Person? = getTheBestPerson()
if (person != null) sendEmailTo(person.email)
// let 사용 ->
getTheBestPerson()?.let { sendEmailTo(it.email) }
```
- let을 쓰면 긴 식의 결과를 저장하는 변수를 따로 만들 필요가 없다. 

- 여러 값이 널인지 검사해야 하는 경우, let 호출을 중첩시켜서 처리할 수 있지만 이렇게 하면 코드가 복잡해진다. 이런 경우 일반적인 if를 사용해 한꺼번에 검사하는 편이 낫다.

#### 나중에 초기화할 프로퍼티
- 코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메소드 안에서 초기화할 수는 없다.
- 생성 단계에서 초기화 값을 제공할 수 없다면 널이 될 수 있는 타입을 사용할 수 밖에 없다. 이렇게 하면 모든 프로퍼티 접근에 널 검사를 넣거나 !!연산자를 써야 한다.
- 프로퍼티 선언에 lateinit 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있다.
- 나중에 초기화하는 프로퍼티는 항상 var이어야 한다. 나중에 초기화하는 프로퍼티는 널이 될 수 없는 타입이라 해도 더 이상 생성자 안에서 초기화할 필요가 없다. 
- 나중에 초기화하는 프로퍼티를 초기화하기 전에 프로퍼티에 접근하면 예외가 발생한다.

#### 널이 될 수 있는 타입 확장
- 널이 될 수 있는 타입에 대한 확장 함수를 정의하면, 어떤 메소드를 호출하기 전에 수신 객체 역할을 하는 변수가 널이 될 수 없다고 보장하는 대신 직접 변수에 대해 메소드를 호출해도 확장 함수인 메소드가 알아서 널을 처리해 준다. 
- 일반 멤버 호출은 객체 인스턴스를 통해 디스패치되므로, 그 인스턴스가 널인지 여부를 검사하지 않는다.
	- 객체지향 언어에서 객체의 동적 타입에 따라 적절한 메소드를 호출해주는 방식을 동적 디스패치, 컴파일러가 컴파일 시점에 어떤 메소드가 호출될지 결정해서 코드를 생성하는 방식을 정적 디스패치라고 한다.
- 안전한 호출 없이도 널이 될 수 있는 수신 객체 타입에 대해 선언된 확장 함수를 호출 가능하다.
- 널이 될 수 있는 타입에 대한 확장 함수 내부에서 this는 널이 될 수 있다. 따라서 명시적으로 널 여부를 검사해야 한다. (자바에서는 메소드 안의 this는 그 메소드가 호출된 수신 객체를 가리키므로 항상 널이 아니다. 널이라면 메소드 안으로 들어가지도 못한다.)
- let과 같은 함수도 널이 될 수 있는 타입의 값에 대해 호출할 수 있지만, 널인지 여부를 검사하고 처리하지 않는다. 그러려면 안전한 호출 연산을 사용해야 한다.

#### 타입 파라미터의 널 가능성
- 코틀린에서 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다. 따라서 타입 파라미터 T를 타입 이름으로 사용하면 이름 끝에 ?가 없더라도 T는 널이 될 수 있는 타입이다. 즉 Any? 타입이다.
- 타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한을 지정해야 한다. 
```kotlin
// 타입 상한 지정
fun <T: Any> foo(t:T) {...}
```

#### 널 가능성과 자바
- 코틀린은 자바의 여러 널 가능성 애노테이션을 알아보고, 해당 정보를 활용해 널이 될 수 있는 타입인지 없는 타입인지 알아낸다.
- 널 가능성 애노테이션이 소스코드에 없는 경우, 자바의 타입은 코틀린의 플랫폼 타입이 된다.

- 플랫폼 타입
	- 플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다. 그 타입을 널이 될 수 있는 타입으로 처리해도 되고 없는 타입으로 처리해도 된다. 책임은 개발자에게 있다.
	- 코틀린은 플랫폼 타입의 값에 대해서는 널 안전성 검사를 중복 수행해도 아무 경고도 표시하지 않는다.
	- 플랫폼 타입의 값이 널이 아님을 알고 있다면 아무 검사 없이 값을 사용해도 된다. 만약 아니라면 NullPonterException이 발생한다.
	- 코틀린 컴파일러는 public인 코틀린 함수의 널이 아닌 타입인 파라미터와 수신 객체에 대한 널 검사를 추가해준다. 이런 파라미터 값 검사는 함수 내부가 아니라 함수 호출 시점에 이뤄진다. 즉 사용되고 나서 엉뚱한 시점이 아니라 가능한 한 빨리 예외가 발생한다.
	- 대부분의 자바 API는 널 관련 애노테이션을 사용하지 않기 때문에 모든 타입을 널이 아닌 것처럼 다루게 되는 것을 조심해야 한다. 
	- 코틀린에서 플랫폼 타입을 직접 선언할 수는 없고, 자바 코드에서 가져온 타입반 플랫폼 타입이 된다. IDE나 컴파일러 오류 메시지에서 **String!** 과 같은 타입은 플랫 폼 타입이다. ! 표기는 해단 타입의 널 가능성에 대해 아무 정보도 없다는 뜻이다.

- 상속
	- 코틀린에서 자바 메소드를 오버라이드할 때, 그 메소드의 파라미터와 반환 타입에 대한 널 가능성을 결정해야 한다. 코틀린 컴파일러는 널이 될 수 있는 타입과 없는 타입에 대한 구현을 다 받아들인다. 
	- 코틀린 컴파일러는 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 널이 아님을 검사하는 단언문을 만들어준다. 자바 코드가 그 메소드에게 널 값을 넘기면 이 단언문이 발동돼 예외가 발생한다. 파라미터를 메소드 안에서 사용하지 않는다고 하더라도 예외는 발생한다.
















