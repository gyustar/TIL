## 6. 클래스
> 객체 지향 프로그래밍(OOP)

- 객체란?<br>
  객체는 속성과 동작으로 구성되어 있다. 예를 들어 사람은 이름, 나이 등의 속성과 웃다, 걷다 등의 동작이 있다. 자바는 이 속성과 동작들을 각각 필드(field)와 메소드(method)라고 부른다.
- 객체의 상호작용<br>
  - 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용하면서 동작한다. 그 상호작용 수단은 메소드이다. 객체가 다른 객체의 기능을 이용하는 것이 바로 메소드 호출이다.<br>
  **리턴값 = 객체.메소드(매개값)**-> 도트 연산자로 메소드 호출을 한다. 도트 연산자는 객체의 필드와 메소드에 접근할 때 사용한다.
  - 매개값은 메소드를 실행하기 위해 필요한 데이터이다. 리턴값은 메소드가 실행하고 나서 호출한 곳으로 돌려주는(리턴하는) 값이다.
  - 객체의 상호작용은 객체 간의 메소드 호출을 의미하며 매개값과 리턴값을 통해 데이터를 주고 받는다.
- 객체 간의 관계<br>
  객체는 개별적으로도 사용될 수 있지만, 대부분 다른 객체와 집합 관계, 사용 관계, 상속 관계를 가진다.
  - **집합관계**는 자동차와 핸들처럼 하나는 부품이고 하나는 완성품에 해당한다.
  - **사용관계**는 사람과 자동차처럼 상호작용을 하는 것을 말한다.
  - **상속관계**는 상위(부모)객체를 기반으로 하위(자식)객체를 생성하는 관계이다. 일반적으로 상위 객체는 종류, 하위 객체는 구체적 사물을 의미한다. 기계(상위)와 자동차(하위)처럼.
- 객체 지향 프로그래밍의 특징
  - 캡슐화(Encapsulation)<br>
    캡슐화란 외부의 잘못된 사용으로 객체가 손상되지 않도록 객체의 필드, 메소드를 하나로 묶고 실제 구현 내용을 감추는 것을 말한다. 외부 객체는 객체가 제공하는 필드와 메소드만 이용할 수 있다. 자바는 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다.
  - 상속(Inheritance)<br>
    상위 객체는 가지고 있는 필드와 메소드를 하위 객체에게 상속하여 하위 객체가 사용할 수 있도록 한다.
  - 다형성(Polymorphism)<br>
    다형성은 객체를 부품화시킨다. 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 자바는 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.
> 객체와 클래스

자동차를 만들 때 설계도가 필요한 것처럼, 객체 지향 프로그래밍에서도 메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요하다. 자바에서는 그 설계도가 **클래스(class)** 이다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다. 클래스로부터 만들어진 객체를 해당 클래스의 **인스턴스(instance)** 라고 한다. 클래스로부터 객체를 만드는 과정을 **인스턴스화**라고 한다. main()메소드가 없는 클래스는 객체 생성 과정을 거쳐 사용해야 한다.
> 클래스 선언

- 클래스 이름은 다음의 규칙을 따른다.
  - 하나 이상의 문자로 이루어져야 한다. *ex) Car, SportsCar*
  - 첫 번째 글자는 숫자가 올 수 없다.
  - $, _ 외의 특수 문자는 사용할 수 없다.
  - 자바 키워드는 사용할 수 없다.
- 클래스 이름을 정했다면 클래스이름.java로 소스 파일을 생성해야 한다. 소스파일 이름 역시 클래스 이름과 같게 한다.
  ```java
  public class Car { //클래스 선언의 시작, 파일이름과 동일한 클래스 선언에만 public 사용

  }//클래스 선언의 끝
  class Tire { //일반적으로 소스파일당 하나의 클래스를 선언하지만 그 이상도 가능하다.

  }
  ```
  두개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드파일(.class)은 선언한 클래스 개수만큼 생긴다. 즉 소스 파일은 클래스 선언을 담고 있는 저장 단위이지 클래스 자체가 아니다.
> 객체 생성과 클래스 변수

클래스를 선언 후 컴파일을 하면 객체를 생성할 설계도가 만들어진 것이다. 객체를 생성할 때는 new 연산자를 사용한다. *ex) new 클래스();*<br>
new는 클래스로부터 객체를 생성시키는 연산자이다. new 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴한다. 이 주소를 참조 타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다.
```
클래스 변수;
변수 = new 클래스();
클래스 변수 = new 클래스();
```
- 클래스는 두 가지 용도가 있다. 하나는 라이브러리(API)용, 다른 하나는 실행용이다. 실행 클래스는 main()메소드를 제공하는 역할을 한다.
>클래스의 구성 멤버

클래스의 구성 멤버에는 필드, 생성자, 메소드가 있다. 생략되거나 복수 개가 작성될 수 있다.
- **필드(Field)**<br>
  필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장한다. 선언 형태는 변수와 비슷하다. 필드는 변수와 달리 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 존재한다.<br>
  *ex) int fieldName;*
- **생성자(Constructor)**<br>
  생성자는 new 연산자로 호출되는 특별한 중괄호 문이다. 생성자는 객체 생성 시 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 한다. 클래스 이름으로 되어 있고 리턴 타입이 없다.<br>
  *ex) ClassName() {...}*
- **메소드(Method)**<br>
  메소드는 객체의 동작에 해당하는 중괄호 블록을 말한다. 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다. 메소드는 필드를 읽고 수정하기도 하고 다를 객체를 생성해서 기능을 수행하기도 한다. 메소드는 객체 간의 데이터 전달의 수단으로 사용된다. 매개값을 받을 수 있고, 리턴 값을 가질 수도 있다.<br>
  *ex) void methodName() {...}*
> 필드(field)

- 필드의 선언은 생성자와 메소드 중괄호 블록 내부를 제외한 클래스 중괄호 블록 어디서든 가능하다. (생성자와 메소드 중괄호 블록 내부에 선언된 것은 모두 로컬 변수가 된다.)
- 필드의 타입은 기본 타입과 참조 타입이 모두 올 수 있다. 초기값은 선언 시 주어지거나 생략 가능하다.
  ```java
  //field 선언 예시
  String company = "현대자동차";
  String model = "그랜저";
  int maxSpeed = 300;
  boolean engineStart; // false가 된다.
  //초기값이 없을 경우 자동으로 기본 초기값이 설정된다.
  ```
- 필드 사용<br>
  필드를 사용한다는 것은 필드값을 읽고, 변경하는 작업을 말한다. 클래스 내부에서 사용할 경우 필드 이름으로 읽고 변경하면 되지만, 클래스 외부에서 사용할 경우 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다. *ex) 객체이름.필드이름*<br>
  필드는 객체에 소속된 데이터이므로 객체가 존재해야 필드도 존재한다.
> 생성자(constructor)

- 생성자는 new 연산자와 함께 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다. 객체 초기화란 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 한다는 것을 뜻한다. 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다. 생성자가 성공적으로 실행되면 힙 영역에 객체가 생성되고 객체의 주소가 리턴된다.
- 모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다. 클래스 내부에 생성자 선언이 생략외어 있다면, 컴파일러는 기본 생성자(Default Constructor)를 바이트 코드에 자동 추가한다.<br>
*기본 생성자: [public] 클래스() { }*<br>
- 명시적으로 생성자를 선언하는 이유는 객체를 다양하게 초기화하기 위해서이다. 생성자 블록 내부에는 객체 초기화 코드가 작성된다. 클래스에 생성자가 명시적으로 선언되어 있을 경우에는 반드시 선언된 생성자를 호출해서 객체를 생성해야 한다.
  ```java
  public class Car {
      Car(String model, String color, int maxSpeed) {...}//생성자 선언
      //new연산자로 생성자 호출시, 매개변수에 매개값을 받아야 한다. 
  }
  ```
- 필드 선언 시에 초기화를 하면 객체 생성 시점에 객체별 필드 값은 모두 같다. 객체 생성 시점에 외부에서 제공되는 값으로 필드가 초기화되어야 한다면 생성자에서 초기화를 해야 한다.
  ```java
  public class Korean {
      String nation = "대한민국" //이 필드는 객체 생성 시 모두 대한민국으로 초기화된다.
      String name;
      Strinf ssn;
      public Korean(String name, String ssn) { // 생성자 선언
      //관례적으로 매개변수 이름을 필드의 이름과 동일하게 한다.
        name = name;
        //동일한 이름은 매개변수가 사용 우선순위가 높기 때문에 필드에 접근할 수 없다.
        this.name = name; //this라는 참조변수로 필드를 사용
        this.ssn = ssn; //객체 생성 시 매개변수가 받는 값으로 해당 필드가 초기화된다.
      }
  }
  ```
- 생성자 오버로딩(Overloading)<br>
  외부에서 제공되는 데이터가 다양할수록 생성자도 다양화될 필요가 있다. 생성자 오버로딩이란 매개 변수를 달리 하는 생성자를 여러 개 선언하는 것을 말한다.
  ```java
  //생성자 오버로딩의 예시
  public class Car {
      Car() {...}
      Car(String model) {...}
      Car(String model, String color) {...} //오버로딩

      Car(String model, String color) {...}
      Car(String color, String model) {...} //오버로딩이 아님
      /*매개변수의 타입,개수,선언 순서가 같을 경우,
      매개변수 이름만 바꾸는 것은 오버로딩이 아니다.*/
  }
  ```
- 다른 생성자 호출(this())<br>
  생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다. 이 경우, 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.
  ```java
  //this()는 자신의 다른 생성자를 호출하며, 반드시 생성자의 첫줄에서만 허용된다.
  //this()의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공해야 한다.
  public class Car {
      String company = "현대자동차";
      String model;
      String color;
      int maxSpeed;

      Car(String model) {
          this(model, "은색", 250); //호출
      }
      Car(String model, String color) {
          this(model, color, 250); //호출
      }
      Car(String model, String color, int maxSpeed) {
          this.model = model;
          this.color = color;
          this.maxSpeed = maxSpeed; //공통 실행 코드
      }
  }
  ```
> 메소드

- 메소드 선언은 선언부(Signature)(리턴타입, 메소드이름, 매개변수 선언)와 실행 블록으로 구성된다.
  ```java
  void powerOn() {...} //리턴값과 매개변수가 없는 메소드
  double divide(int x, int y) {...} //리턴타입이 double이고 매개변수를 받는 메소드

  powerOn(); //메소드 호출
  double result = divide(10,20); //호출 시 리턴값을 저장할 변수가 필요하다.
  divide(10,20); //메소드 호출만 하는것도 가능하다.
  ```
- 메소드 이름의 규칙
  - 숫자로 시작하면 안되고, $,_를 제외한 특수문자를 사용하지 않아야 한다.
  - 관례적으로 메소드명은 소문자로 작성한다.
  - 뒤이어 오는 단어의 첫글자는 대문자로 한다.
  - 기능 이름으로 지어주는 것이 좋다.
- 매개 변수의 수를 모를 경우
  ```java
  //다음과 같이 매개 변수로 배열타입을 선언할 수 있다.
  int sum1(int[] values) { }
  
  //호출 시
  int[] values = {1, 2, 3};
  int result = sum1(values);
  int result = sum1(new int[] {1, 2, 3, 4, 5});

  //배열을 생성하지 않고 값의 리스트만 넘길 수도 있다.
  int sum2(int ... values) { }
  /*위처럼 매개 변수를 ... 을 사용해서 선언하면, 메소드 호출 시
  넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.*/
  int result = sum2(1, 2, 3); //메소드 호출 시 리스트로 나열해주면 된다.
  ```
- 리턴값이 없는 메소드에서 return;하면, 그 시점에서 즉시 메소드를 종료시킨다.
- 메소드 오버로딩<br>
  클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩이라고 한다. 하나의 메소드 이름으로 여러 기능을 담는다. 메소드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다.<br>
  오버로딩된 메소드를 호출할 경우 JVM은 매개값을 보고 메소드를 선택한다.
> 인스턴스 멤버와 this

인스턴스 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 각각 인스턴스 필드, 인스턴스 메소드라고 부른다. 이들은 객체에 소속된 멤버이기 때문에 객체없이는 사용할 수 없다. 인스턴스 필드는 객체마다 따로 존재하고, 인스턴스 메소드는 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다. 객체 내부에서 인스턴스 멤버에 접근하려면 this를 사용하면 된다.
> 정적 멤버와 static

정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다. 이를 각각 정적 필드, 정적 메소드라고 부른다. 정적 멤버는 클래스에 소속되었기 때문에 클래스 멤버라고도 한다.
- 정적 멤버 선언은 선언 시 static 키워드를 추가적으로 붙여주면 된다.<br>
  *ex) static int speed;*
- 정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로, 클래스 로더가 클래스(바이트 코드)를 로딩해서 **메소드 메모리 영역**에 적재할 때 클래스별로 관리된다. 따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다.
- 정적 멤버는 클래스 이름과 함께 도트 연산자로 접근해서 사용할 수 있다.<br>
*객체 참조 변수로도 접근이 가능하다. 하지만 클래스 이름으로 접근하는 것이 좋다.*
- 정적 필드를 초기화할 때, 계산이 필요한 경우 정적 블록을 사용한다.
  ```java
  static String company = "Apple";
  static String model = "iphone";
  static String info;

  static { 
      info = company + "-" + model; //"Apple-iphone"
  } //정적 메소드와 블록 내부에 인스턴스 멤버는 사용할 수 없다. this 키워드도 불가하다.
  //사용하고 싶다면 아래처럼 객체를 먼저 생성 후 참조 변수로 접근해야 한다.
  static boid Method() {
      ClassName obj = new ClassName();
      obj.field1 = 10;
      obj.method2();
  }
  ```
- main()메소드도 정적 메소드이다!
- 싱글톤(Singleton)<br>
  프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우, 이 객체를 싱글톤이라고 한다. 싱글톤을 만드려면, 생성자 앞에 **private**접근 제한자를 붙여줘서 클래스 외부에서 new연산자로 생성자를 호출할 수 없도록 막아야 한다.
  ```java
  //싱글톤 만들기
  public class Car {
      //정적 필드를 자신의 타입으로 선언하고 자신의 객체를 생성해 초기화한다.
      //정적 필드도 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하게 한다.
      private static Car singleton = new Car();

      private Car() {} //생성자 선언

      static Car getInstance() {
          return singleton;
      }/*외부에서 호출할 수 있는 정적 메소드를 선언하고,
      정적 필드에서 참조하고 있는 자신의 객체를 리턴한다.*/
  }//외부에서 객체를 얻는 유일한 방법은 getInstance() 메소드 호출 뿐이다.
  ```
> final 필드와 상수(static final)

- final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중 수정할 수 없다. final 필드의 초기값을 줄 수 있는 방법은 두 가지다.
  - 필드 선언 시 주는 방법
  - 생성자에서 주는 방법
  - 초기화되지 않은 final 필드를 그대로 남겨두면 컴파일 에러가 발생한다.
- 상수는 static이면서 final이어야 한다. static final 필드는 객체마다 저장되지 않고, 클래스에만 포함된다. 한 번 초기값이 저장되면 변경할 수 없다.
  - 복잡한 초기화일 경우 정적 블록에서도 상수를 초기화할 수 있다.
  - 상수 이름은 모두 대문자와 _로 표현하는 것이 관례이다.
> 패키지

- 자바에서는 클래스를 체계적으로 관리하기 위해 패키지를 사용한다. 패키지는 파일 시스템의 폴더 기능도 하면서 클래스의 일부분이다. 패키지는 클래스를 유일하게 만들어주는 식별자 역할을 한다. 클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식한다. 클래스의 전체 이름은 *'상위 패키지.하위 패키지.클래스명'* 이다.<br>
- 클래스만 따로 복사해서 이동할 경우 클래스는 사용할 수 없다. 패키지 전체를 이동시켜야 한다.
- 패키지는 클래스를 컴파일하는 과정에서 자동적으로 생성되는 폴더이다. 컴파일러는 클래스에 포함되어 있는 패키지 선언을 보고, 파일 시스템의 폴더로 자동 생성시킨다.<br>
  *package 상위패키지.하위패키지;*
  - 숫자로 시작해서는 안되고, $,_를 제외한 특수 문자 사용은 안된다.
  - java로 시작하는 패키지는 자바 표준API에서만 사용하므로 사용해서는 안된다.
  - 모두 소문자로 작성하는 것이 관례이다.
- 패키지 선언이 포함된 클래스를 명령 프롬프트에서 컴파일할 경우, 패키지 폴더가 자동으로 생성되게 하려면 javac 명령어 다음에 -d옵션을 추가하고 패키지가 생성될 경로를 저장해야 한다.
- 패키지에 소속된 클래스를 명령 프롬프트에서 실행하려면 바이트 코드 파일(.class)이 있는 폴더가 아니라 패키지가 시작하는 폴더에서 java 명령어를 사용해야 한다.
- 같은 패키지에 속하는 클래스는 다른 클래스를 사용할 수 있지만, 다른 패키지에 속하는 클래스를 사용할 때는 두 가지 방법이 있다.
  - 패키지와 클래스를 모두 기술한다.<br>
    *ex) com.hankook.Tire tire = new com.hankook.Tire();*
  - 사용하고자 하는 패키지를 패키지 선언과 클래스 선언 사이에 import문으로 선언하고, 클래스를 사용할 때는 패키지를 생략한다.<br>
    *ex) import com.hankook.Tire; 또는 import com.hankoon.\*;*<br>
    *은 패키지에 속하는 모든 클래스들을 의미한다. import는 대상의 하위 패키지까지 포함하지 않는다.
  - 서로 다른 패키지에 동일한 클래스 이름이 존재하고, 두 패키지 모두 import되어 있을 경우, 첫번째 방법으로 정확하게 패키지 이름 전체를 기술해야 한다.
> 접근 제한자(Access Modifier)

접근 제한자는 public, protected, default, private 네 종류가 있다.
- public 접근 제한자는 외부 클래스가 자유롭게 사용할 수 있는 공개 멤버를 만든다.<br>
  *적용대상: 클래스, 필드, 생성자, 메소드*
- protected 접근 제한자는 같은 패키지 또는 자식 클래스에서 사용할 수 있는 멤버를 만든다.<br>
  *적용대상: 필드, 생성자, 메소드*
- private 접근 제한자는 외부에 노출되지 않는 멤버를 만든다.<br>
  *적용대상: 필드, 생성자, 메소드*
- 위 세 가지 접근 제한자가 적용되지 않는 멤버는 dsfault 접근 제한을 가진다. 같은 패키지에 소속된 클래스에서만 사용할 수 있는 멤버를 만든다.<br>
  *적용대상: 클래스, 필드, 생성자, 메소드*

> Getter와 Setter 메소드

- 일반적으로 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다. 데이터는 외부에서 접근할 수 없도록 막고 메소는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도한다. 메소드는 매개값을 검증해서 유효한 값만 데이터로 저장할 수 있기 때문이다. 이런 역할을 하는 것이 **Setter** 메소드이다.
- 외부에서 객체의 데이터를 읽을 때도, 객체 외부에서 객체의 필드값을 사용하기에 부적절한 경우 메소드로 필드값을 가공한 후 외부로 전달한다. 이런 메소드가 **Getter** 메소드이다.
- 클래스를 선언할 때 가능하면 필드를 private로 선언해서 보호하고, 필드에 대한 메소드를 작성해서 필드값을 안전하게 변경/사용하는 것이 좋다.
  ```java
  private boolean stop; //필드 선언

  //Getter
  public boolean isStop() {
      //메소드 이름은 필드 타입이 boolean일 경우 is~/일반적으로 get~
      //변환 코드
      return stop;
  }

  //Setter
  public void setStop(boolean stop) {
      //메소드 이름은 일반적으로 set~
      //검증 코드
      this.stop = stop;
  }
  ```

> 어노테이션(Annotation)

- 어노테이션은 메타데이터(Metadata)라고 볼 수 있다. 메타데이터란 애플리케이션이 처리해야 할 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보이다.어노테이션의 용도는 다음과 같다.<br>
  -  컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
  -  소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
  -  실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공<br>

  @Override 어노테이션은 메소드 선언 시 사용되어, 메소드가 오버라이드(재정의)된 것임을 컴파일러에게 검사하도록 해준다. 어노테이션은 빌드 시 자동으로 XML 설정 파일을 생성하거나, 배포를 위해 JAR 압축 파일을 생성하는데에도 사용된다. 실행 시 클래스의 역할을 정의하기도 한다.
```java
//어노테이션 타입의 정의
public @interface AnnotationName {//어노테이션은 엘리먼트를 멤버로 가질 수 있다.
    String elementName1();
    int elementName2() default 5;
    /*엘리먼트의 타입은 기본 데이터 타입이나 String,열거,Class,
    그리고 이들의 배열 타입을 사용할 수 있다.
    엘리먼트의 이름 뒤에는 메소드처럼 ()를 붙여야 한다.*/
}

@AnnotationName(elementName1="값", elementName2=3);
//정의한 어노테이션 사용(적용)
@AnnotationName(elementName1="값");
//elementName2는 디폴트 값이 있기 때문에 생략 가능
```
- 어노테이션을 적용할 수 있는 대상은 **java.lang.annotation.ElementType 열거 상수로 정의되어 있다.
  - TYPE : 클래스, 인터페이스, 열거 타입
  - ANNOTATION_TYPE : 어노테이션
  - FIELD : vlfem
  - CONSTRUCTOR : 생성자
  - METHOD : 메소드
  - LOCAL_VARIABLE : 로컬 변수
  - PACKAHE : 패키지

  어노테이션이 적용될 대상을 지정할 때에는 @Target 어노테이션을 사용한다. 어노테이션이 적용될 대상을 복수 개로 지정하기 위해 @Target의 기본 엘리먼트인 value는 ElementType배열을 값으로 가진다.
- 어노테이션 정의 시, 사용 용도에 따라 @AnnotaitonName을 어노 범위까지 유지할 것인지 지정해야 한다. 어노테이션 유지 정책은 **java.lang.annotation.RetentionPolicy** 열거 상수로 정의되어 있다.
  - SOURCE : 소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다.
  - CLASS : 바이트 코드파일까지 정보를 유지한다. 하지만 리플렉션을 이용해서 정보를 얻을 수 없다.
  - RUNTIME : 바이트 코드 파일까지 정보를 유지하면서 리플렉션을 이용해 런타임 시에 어노테이션 정보를 얻을 수 있다.
  
  리플렉션(Reflection)이란 런타임 시에 클래스의 메타 정보를 얻는 기능을 말한다. 즉, 클래스의 필드, 생성자, 메소드, 적용된 어노테이션의 정보를 알아낸다.
- 어노테이션 자체는 아무런 동작을 가지지 않는 표식이지만, 리플렉션을 이용해서 어노테이션 적용 여부와 엘리먼트 값을 읽고 처리할 수 있다. 클래스에 적용된 어노테이션 정보는 **java.lang.Class**를 이용해 얻으면 된다. 필드, 생성자, 메소드에 적용된 어노테이션 정보를 얻으려면 Class의 다음 메소드를 통해서 java.lang.reflect 패키지의 리턴 타입들을 받아야 한다.
  ```
  리턴 타입         | 메소드명(매개 변수)        | 설명
  Field[]         | getFields()           | 필드 정보를 Field 배열로 리턴
  Constructor[]   | getconstructors()     | 생성자정보를 Constructor 배열로 리턴
  Method[]        | getDeclareMethods()   | 메소드 정보를 Method 배열로 리턴
  ```
  
  그런 다음 Class, Field, Constructor, Methd가 가지고 있는 메소드를 호출해서 적용된 어노테이션 정보를 얻을 수 있다.

## 7. 상속(Inheritance)

> 상속 개념

객체 지향 프로그램에서, 부모 클래스(상위 클래스)의 멤버를 자식 클래스(하위 클래스, 파생 클래스)에게 물려줄 수 있다. 단, 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다. 그리고 부모와 자식이 서로 다른 패키지에 속해있다면, default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다. 상속은 코드의 중복을 줄여주고 클래스의 수정을 최소화시킨다.

>클래스 상속

- 현실과 달리 프로그램에서는 자식이 부모를 선택해서 상속을 받는다. 다른 언어와 달리 자바는 다중 상속을 허용하지 않는다. 즉 하나의 자식이 여러 개의 부모 클래스를 상속할 수 없다.
  ```java
  class 자식클래스 extends 부모클래스 {
      //필드
      //생성자
      //메소드
  }
  ```
- 자식 클래스의 객체를 생성하면, 내부적으로 부모클래스의 객체가 먼저 생성되고 자식클래스의 객체가 생성된다. 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다.
  ```java
  //자식 생성자가 명시적으로 선언되지 않았을 경우, 아래의 기본 생성자가 생성된다.
  public 자식클래스이름() {
      super();
  }//super()는 부모의 기본 생성자를 호출한다.

  //직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하는 경우
  자식클래스(매개변수 선언) {
      super(매개값);
      ...
  }/*super(매개값)는 매개값의 타입과 일치하는 부모 생성자를 호출한다.
  super(매개값)을 생략할 경우 super()가 자동 추가되기 때문에
  부모의 기본 생성자가 있어야 한다.*/

  //super(매개값)은 반드시 자식 생성자 첫 줄에 위치해야 한다.
  ```

> 메소드 재정의

- 부모 클래스의 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수 있다. 이 경우 메소드 오버라이딩(Overriding)기능으로 자식클래스에서 메소드를 재정의 해서 사용할 수 있다. 메소드가 오버라이딩되었다면 부모 객체의 메소드는 자식 클래스에서 숨겨진다. 메소드 오버라이딩은 다음의 규칙을 가진다.
  - 부모의 메소드와 동일한 시그니처(리턴 타입, 메소드 이름, 매개 변수 리스트)를 가져야 한다.
  - 접근 제한을 더 강하게 오버라이딩할 수 없다.
  - 새로운 예외(Exception)를 throws할 수 없다.
  - 오버라이딩할 메소드에 @Override 어노테이션은 생략할 수 있으나, 붙여주면 매소드가 정확히 오버라이딩되었는지 컴파일러가 체크해준다.
- 만약 오버라이딩되어 숨겨진 부모 클래스의 메소드를 자식 클래스 내부에서 호출해야 하는 경우, 명시적으로 super 키워드를 붙여서 호출할 수 있다. super는 부모 객체를 참조하기 때문에 부모 메소드에 직접 접근한다.<br>
  *ex) super.부모메소드();*

> final 클래스와 final 메소드

final 키워드는 클래스, 필드, 메소드 선언 시에 사용할 수 있다. final 필드의 경우 초기값 설정 후 더 이상 값을 변경할 수 없다. 메소드와 클래스 선언 시에 final 키워드를 사용하면 상속과 관련이 있다.
- 클래스를 선언할 때 final 키워드를 class앞에 붙이게 되면 이 클래스는 최종적인 클래스가 되어 상속할 수 없는 클래스가 된다. 즉, 부모 클래스가 될 수 없다. 대표적 예는 String 클래스이다.
- 메소드를 선언할 때 final 키워드를 붙이면 이 메소드는 최종적인 메소드가 되어 오버라이딩할 수 없는 메소드가 된다. 

> protected 접근 제한자

네 가지 접근 제한자 중 protected 는 상속과 관련이 있다. 같은 패키지에서만 접근을 할 수 있는 default와 달리 다른 패키지에서도 자식 클래스라면 접근을 허용한다. 단, new연산자를 사용해서 생성자를 직접 호출할 수 는 없고, 자식 생성자에서 super()로 부모 생성자를 호출해야 한다.

> 타입 변환과 다형성

다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있다. 다형성을 위해 자바는 부모 클래스로 타입 변환을 허용한다. 즉, 부모 타입에 모든 자식 객체가 대입될 수 있다. 클래스 타입도 기본 타입처럼 상속관계에 있는 클래스 사이에서 변환될 수 있다. 자식 타입은 부모 타입으로 자동 타입 변환이 가능하다.
- **자동 타입 변환(Promotion)**으로 자식 클래스 타입 변수가 부모 클래스 타입으로 변환되었을 경우, 변환된 변수는 여전히 자식 클래스의 주소를 참조한다. 하지만 부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다. 단, 메소드가 자식 클래스에서 오버라이딩되었다면 자식 클래스의 메소드가 호출된다.<br>
바로 위의 부모가 아니더라도 상속 계층에서 상위 타입이라면 자동 타입 변환이 가능하다.
  - 필드에 이 다형성 기능을 사용하면, 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행 결과가 달라지고 부품의 교체가 쉬워진다.
  - 다형성 기능을 이용하면, 메소드의 매개값을 다양화하기 위해 매개변수로 지정된 객체 대신 자식 타입 객체를 지정할 수도 있다.
    ```java
    class Driver {
        void drive(Vehicle vehicle) {
            vehicle.run();
        }
    }/*drive메소드 호출 시, 만약 Vehicle의 자식 클래스인
    Bus객체를 매개값으로 넣는다면 자동 타입 변환이 발생한다.*/
    ```
  - 만약 매개 변수의 타입이 클래스일 경우, 마찬가지로 해당 클래스의 자식 객체까지도 매개값으로 사용될 수 있다. 만약 자식 객체가 부모의 메소드를 오버라이딩했다면, 메소드 내부에서 매개값으로 받은 객체의 오버라이딩된 메소드를 호출함으로써 실행 결과는 다양해진다.
- **강제 타입 변환(Casting)**은 부모 타입을 자식 타입으로 변환하는 것을 말한다. 자식 타입이 부모 타입으로 자동 변환 후, 다시 자식 타입으로 변환할 때에 한해서 강제 타입 변환을 사용할 수 있다.<br>
자식 타입이 부모 타입으로 자동 타입 변환하면 부모 타입에 선언된 필드와 메소드만 사용 가능하기 때문에, 만약 자식 타입에 선언된 필드와 메소드를 사용해야 한다면 강제 타입 변환을 한 후 사용하면된다.
  ```java
  Parent parent = new Child();  //자동 타입 변환
  Child child = (Child) parent; //강제 타입 변환
  ```
- **객체 타입 확인(instanceof)**<br>
  어떤 객체가 어떤 클래스의 인스턴스인지 확인하려면 instanceof 연산자를 사용하면 된다. 연산자의 좌항은 객체가 오고, 우항은 타입이 오는데, 좌항의 객체가 우항의 인스턴스이면 true, 그렇지 않으면 false를 산출한다. 주로 매개값의 타입을 조사한 후 가능한 경우에 한해 강제 타입 변환을 하는 경우에 사용된다.<br>
  *ex) boolean result = 좌항(객체) instanceof 우항(타입)*<br>

> 추상(abstract) 클래스

추상은 실체 간에 공통되는 특성을 추출한 것을 말한다. 클래스에서, 객체를 직접 생성할 수 있는 클래스를 실체 클래스라고 한다면 공통적인 특성, 즉 공통되는 필드와 메소드를 따로 선언한 클래스를 추상 클래스라고 한다. 추상 클래스는 객체를 직접 생성해서 사용할 수 없다. 실체 클래스를 만들기 위한 부모 클래스로만 사용된다.
- 추상 클래스를 만드는 목적
  - 실체 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적
  - 실체 클래스를 작성할 때 시간을 절약
- 추상 클래스를 선언할 때에는 클래스 선언에 abstract 키워드를 붙여야 한다. 이렇게 하면 new 연산자를 이용해서 객체를 만들지 못하고 상속을 통해 자식 클래스만 만들 수 있다.
- 추상 클래스도 필드, 생성자, 메소드 선언을 할 수 있다. new 연산자로 직접 생성자를 호출할 수는 없지만, 자식 객체가 생성될 때 super()를 호출해서 추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 있어야 한다. 
- 실체 클래스들이 사용하는 메소드의 선언만 통일화하고, 실행 내용은 클래스마다 달라야 하는 경우가 있다. 이런 경우 추상 클래스는 abstract 키워드를 붙여서 **추상 메소드**를 선언할 수 있다. 추상 메소드는 추상 클래스에서만 선언할 수 있는데, 메소드의 선언부만 있고 실행 내용인 중괄호문은 없는 메소드를 말한다. 자식 클래스는 반드시 추상 메소드를 오버라이딩 해서 실행 내용을 작성해야 한다.